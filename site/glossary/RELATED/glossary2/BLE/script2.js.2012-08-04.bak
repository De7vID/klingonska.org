/*jslint browser: true, regexp: true, todo: true */
/*global $ */
/*

 * 'root' should look the same as that 'part'
 * Glossary table freqency count should be dependant on PoS.
 * Create FSM from dictionary.
 * Totals word count for glossary table.
 * paghlogh / Hochlogh / paghDIch / HochDIch
 * Text count should count unique words.
 * Number lines in glossary table?

 * splitSyllable() should not be in the global scope
 * parseZDB() should not be in the global scope


  TODO

  * Text and glossary list should have a line where the number of words, verbs,
    nouns etc are listed.
  * Hovering over syllable in text should display the root word
    interpretations.
  * Color marking should be according to the part-of-speech of the *whole*
    word, while extracted glossary should be the root word (e.g. {ngotlhwI'}
    should be color marked as a noun, but included in the glossary should be
    {ngotlh} "be fanatical").
  * get -wI'- and -ghach- verbs right
  * Explanatory words under input field should be clickable (and enable/disable
    highlight of their respective categories)
  * User should be able to select interpretations by clicking on words in input
    field (to clear up ambiguous words).

  * Hover over word in table should highlight all occurances of word in input
    field.
  * Hover over word in cheat-sheet should highlight word in input field.

  MEBBE LATER
  * Add affixes to glossary.

 */


// Usage: insertRule(rules, sylls, pos, suffixRules);
//
// Inserts a rule into 'rules' for the specified word (defined by 'sylls',
// 'pos' and 'suffixRules').
//
// 'sylls' is a list containing the syllables of the word. 'pos' is the
// part-of-speech strin (e.g. 'v', 'n', 'pro', 'conj' etc.) 'suffixRules' is
// the ruleset for any trailing suffixes of the word.
function insertRule(rules, sylls, pos, suffixRules) {
    'use strict';
    var index = null, first = sylls.shift();
    if (rules[first]) {                // if syllable rule exists
        rules[first].some(             //   and subrule for pos exist
            function (state, i) {      //     remember its index
                if (pos === state.tag) {
                    index = i;
                    return true;
                }
            }
        );
    } else {                           // otherwise
        rules[first] = [];             //   create empty rule
    }
    if (index === null) {          // create subrule if none found
        index = rules[first].length;
        rules[first].push({});
    }
    if (sylls.length === 0) {          // last syllable
        rules[first][index].tag = pos; //   add part-of-speech
        if (suffixRules) {             //   and suffix rules
            rules[first][index].rules = suffixRules;
        }
        return;
    }
    rules[first][index].rules = rules[first][index].rules || {};
    insertRule(rules[first][index].rules, sylls, pos, suffixRules);
}

function insertRules(rules, affixes, suffixRules) {
    'use strict';
    Object.keys(affixes).forEach(function (affix) {
        insertRule(rules, [affix], affixes[affix], suffixRules);
        //rules[affix] = [{ tag: affixes[affix], rules: suffixRules }];
    });
}

// split a Klingon word into syllables
function splitSyllable(word) {
    'use strict';
    return word.split(/(?=(?:[bDHjlmnpqQrStvwy\']|ch|gh|ng|tlh)[aeIou])/);
}

// Usage: parseZDB(data, func);
//
// Chew through a ZDB database, calling 'func' for each entry. 'func' will be
// passed entry object looking like this:
//
//     {
//         "tlh" : "{bach} [2]",
//         "pos" : "noun",
//         "sv"  : "skott",   // any «...» and <...> stripped
//         "en"  : "shot",    // any «...» and <...> stripped
//         "def" : "TKD",
//         "cat" : "fighting",
//         "data": "KLCP-1",
//         "file": "1992-01-01-tkd.txt",
//     }
//
function parseZDB(data, func) {
    'use strict';
    // dictionary data preprocessing (strip header + footer etc.)
    data = data.replace(/^[\s\S]*\n=== start-of-word-list ===\n+/, ''); // head
    data = data.replace(/\n+=== end-of-word-list ===\n[\s\S]*$/, '');   // foot
    data = data.replace(/[«»<>]+/g, '');       // remove translation tags
    data = data.replace(/\n\t/g, ' ');         // unwrap long lines
    data.split(/\n{2,}/).forEach(              // foreach entry
        function (entry) {
            var obj = {};                      //   init entry object
            entry.split(/\n/).forEach(         //     for each field
                function (field) {             //       insert key/value
                    var keyval = field.split(/:\s+/, 2);
                    obj[keyval[0]] = keyval[1];
                }
            );
            func(obj);                         //    invoke callback w/ object
        }
    );
}


/*****************************************************************************\
**                                                                           **
** ECMAScript 5 Compatibility Functions for Older Browsers                   **
**                                                                           **
\*****************************************************************************/
(function () {
    'use strict';
    // Add Object.create()
    if (typeof Object.create !== 'function') {
        Object.create = function (o) {
            function F() {}
            F.prototype = o;
            return new F();
        };
    }
    // Add Object.keys()
    if (!Object.keys) {
        Object.keys = (function () {
            var hasOwnProperty = Object.prototype.hasOwnProperty,
                hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
                dontEnums = [
                    'toString',
                    'toLocaleString',
                    'valueOf',
                    'hasOwnProperty',
                    'isPrototypeOf',
                    'propertyIsEnumerable',
                    'constructor'
                ],
                dontEnumsLength = dontEnums.length;
            return function (obj) {
                var result = [], prop, i;
                if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null) {
                    throw new TypeError('Object.keys called on non-object');
                }
                for (prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        result.push(prop);
                    }
                }
                if (hasDontEnumBug) {
                    for (i = 0; i < dontEnumsLength; i += 1) {
                        if (hasOwnProperty.call(obj, dontEnums[i])) {
                            result.push(dontEnums[i]);
                        }
                    }
                }
                return result;
            };
        }());
    }
}());

(function (document) {
    'use strict';
    /*jslint white: true */
    var wordRules, dict, taggedStringPrototype, wordPrototype, clearTimer,
        inputElement, outputElement, tlhSortkey,
        isRoot = {
            'adv'  : true,  'conj' : true,  'excl' : true,  'n'    : true,
            'name' : true,  'num'  : true,  'pro'  : true,  'ques' : true,
            'v'    : true,
            // empty pos = non-final syllable of multi syllable word
            '': true
        },
        isPos = {
            "adv" : "adv",   "conj": "conj",  "excl": "excl",  "name": "name",
            "n"   : "n",     "ns1" : "n",     "ns2" : "n",     "ns3" : "n",
            "ns4" : "n",     "ns5" : "n",     "num" : "num",   "num1": "num",
            "num2": "num",   "pro" : "pro",   "ques": "ques",  "v"   : "v",
            "vs1" : "v",     "vs2" : "v",     "vs3" : "v",     "vs4" : "v",
            "vs5" : "v",     "vs6" : "v",     "vs7" : "v",     "vs8" : "v",
            "vs9" : "v",     "vs9n": "n",     "vsr" : "v"
        };
    /*jslint white: false */

    /*************************************************************************\
    **                                                                       **
    ** Word Parse Rule Loader                                                **
    **                                                                       **
    \*************************************************************************/
    // Object Anatomy
    // --------------
    // var rules = {
    //     "bach": [{ tag: 'n',  rules: nsRules }],
    //     "batlh": [
    //         { tag: 'adv' },
    //         { tag: 'n', rules: nsRules }
    //     ],
    //     //...
    //     "ghIp": [{
    //         rules: {
    //             "DIj": [{ tag: 'v', rules: vsRules }]
    //         }
    //     }],
    //     //...
    // }
    function getRules(data) {
        /*jslint white: true */
        var nsRules = {}, vsRules = {}, numRules = {},
            verbRules = {}, advsRules = {}, rules = {},
            posAbbrev = {
                "adverbial"             : "adv",   "conjunction"       : "conj",
                "exclamation"           : "excl",  "name"              : "name",
                "noun"                  : "n",     "noun suffix type 1": "ns1",
                "noun suffix type 2"    : "ns2",   "noun suffix type 3": "ns3",
                "noun suffix type 4"    : "ns4",   "noun suffix type 5": "ns5",
                "numeral"               : "num",   "pronoun"           : "pro",
                "question word"         : "ques",  "verb"              : "v",
                "verb prefix"           : "vp",    "verb suffix type 1": "vs1",
                "verb suffix type 2"    : "vs2",   "verb suffix type 3": "vs3",
                "verb suffix type 4"    : "vs4",   "verb suffix type 5": "vs5",
                "verb suffix type 6"    : "vs6",   "verb suffix type 7": "vs7",
                "verb suffix type 8"    : "vs8",   "verb suffix type 9": "vs9",
                "verb suffix type rover": "vsr"
            },
            suffixRules = {
                'adv': advsRules,
                'conj': {},
                'excl': {},
                'name': nsRules,
                'n': nsRules,
                'num': {},
                'pro': vsRules,
                'ques': {},
                'v': vsRules,
                'vp': verbRules
            },
            verbPrefixes = {
                "bI" : 'vp',  "bo" : 'vp',  "che": 'vp',  "cho": 'vp',
                "Da" : 'vp',  "DI" : 'vp',  "Du" : 'vp',  "gho": 'vp',
                "HI" : 'vp',  "jI" : 'vp',  "ju" : 'vp',  "lI" : 'vp',
                "lu" : 'vp',  "ma" : 'vp',  "mu" : 'vp',  "nI" : 'vp',
                "nu" : 'vp',  "pe" : 'vp',  "pI" : 'vp',  "qa" : 'vp',
                "re" : 'vp',  "Sa" : 'vp',  "Su" : 'vp',  "tI" : 'vp',
                "tu" : 'vp',  "vI" : 'vp',  "wI" : 'vp',  "yI" : 'vp'
            },
            verbSuffixes = { // except {-wI'} and {-ghach}
                "'egh" : 'vs1',  "chuq" : 'vs1',  "nIS"  : 'vs2',
                "qang" : 'vs2',  "rup"  : 'vs2',  "beH"  : 'vs2',
                "vIp"  : 'vs2',  "choH" : 'vs3',  "qa'"  : 'vs3',
                "moH"  : 'vs4',  "lu'"  : 'vs5',  "laH"  : 'vs5',
                "chu'" : 'vs6',  "bej"  : 'vs6',  "law'" : 'vs6',
                "ba'"  : 'vs6',  "pu'"  : 'vs7',  "ta'"  : 'vs7',
                "taH"  : 'vs7',  "lI'"  : 'vs7',  "neS"  : 'vs8',
                "DI'"  : 'vs9',  "chugh": 'vs9',  "pa'"  : 'vs9',
                "vIS"  : 'vs9',  "bogh" : 'vs9',  "meH"  : 'vs9',
                "mo'"  : 'vs9',  "'a'"  : 'vs9',  "jaj"  : 'vs9',
                "be'"  : 'vsr',  "Qo'"  : 'vsr',  "Ha'"  : 'vsr',
                "qu'"  : 'vsr'
            },
            nounSuffixes = {
                "'a'"  : 'ns1',  "Hom"  : 'ns1',  "'oy"  : 'ns1',
                "oy"   : 'ns1',  "pu'"  : 'ns2',  "Du'"  : 'ns2',
                "mey"  : 'ns2',  "qoq"  : 'ns3',  "Hey"  : 'ns3',
                "na'"  : 'ns3',  "wIj"  : 'ns4',  "wI'"  : 'ns4',
                "maj"  : 'ns4',  "ma'"  : 'ns4',  "lIj"  : 'ns4',
                "lI'"  : 'ns4',  "raj"  : 'ns4',  "ra'"  : 'ns4',
                "Daj"  : 'ns4',  "chaj" : 'ns4',  "vam"  : 'ns4',
                "vetlh": 'ns4',  "Daq"  : 'ns5',  "vo'"  : 'ns5',
                "mo'"  : 'ns5',  "vaD"  : 'ns5',  "'e'"  : 'ns5'
            },
            numericalElements = { // except {-SanID}
                "wa'"  : 'num',  "cha'" : 'num',  "wej"  : 'num',
                "loS"  : 'num',  "vagh" : 'num',  "jav"  : 'num',
                "Soch" : 'num',  "chorgh":'num',  "Hut"  : 'num',
                "maH"  : 'num1', "vatlh": 'num1', "SaD"  : 'num1',
                "netlh": 'num1', "bIp"  : 'num1', "'uy'" : 'num1',
                "DIch" : 'num2', "logh" : 'num2'
            };
            /*jslint white: false */


        // Verb Prefix Rules
        // Object.keys(verbPrefixes).forEach(function (prefix) {
        //     rules[prefix] = [{ tag: verbPrefixes[prefix], rules: verbRules }];
        // });
        //
        // Verb Suffix Rules
        // Object.keys(verbSuffixes).forEach(function (suffix) {
        //     vsRules[suffix] = [{ tag: verbSuffixes[suffix], rules: vsRules }];
        // });
        // vsRules["wI'"]   = [{ tag: 'vs9n', rules: nsRules }]; // nominalizers
        // vsRules["ghach"] = [{ tag: 'vs9n', rules: nsRules }];
        //
        // Noun Suffix Rules
        // Object.keys(nounSuffixes).forEach(function (suffix) {
        //     nsRules[suffix] = [{ tag: nounSuffixes[suffix], rules: nsRules }];
        // });

        insertRules(rules, verbPrefixes, verbRules);           // Verb Prefix Rules
        insertRules(vsRules, verbSuffixes, vsRules);           // Verb Suffix Rules
        insertRule(vsRules, ["wI'"],   'vs9n', nsRules);       //   nominalizer
        insertRule(vsRules, ["ghach"], 'vs9n', nsRules);       //   nominalizer
        insertRules(nsRules, nounSuffixes, nsRules);           // Noun Suffix Rules
        insertRules(numRules, numericalElements, numRules);    // Numerical Element Rules
        insertRule(numRules, ["Sa", "nID"], 'num1', numRules); // FIXME!!

        //console.log('nsRules = ' + JSON.stringify(nsRules,null,4));
        //console.log('numRules = ' + JSON.stringify(rules['Sa'],null, 2));


        parseZDB(data, function (entry) {
            var tlh = (entry.tlh.match(/\{(.*?)\}/))[1], // Klingon word
                pos = posAbbrev[entry.pos],              // part-of-speech
                sylls = splitSyllable(tlh);
            if (!tlh.match(/[ ]/)) {
                if (pos === 'v') {                           // add to 'verbRules'
                    insertRule(verbRules, sylls, pos, vsRules);
                }
                if (pos === 'pro') {                           // add to 'verbRules'
                    insertRule(rules, sylls, pos, nsRules);
                }
                //console.log(pos + ' -> '+ suffixRules[pos]);
                insertRule(rules, sylls, pos, suffixRules[pos] || null);
            }
            // // add entry to dictionary
            // if (!dict[tlh]) {                  // create empty entry for word
            //     dict[tlh] = { "tags": [] };
            // }
            // if (dict[tlh].tags.indexOf(pos) === -1) {
            //     dict[tlh].tags.push(pos);      //   add part-of-speech
            // }
            // dict[tlh][pos] = entry;            //   insert actual entry
        });

        //console.log('rules = ' + JSON.stringify(rules['bach'],null, 2));

        insertRule(advsRules, ["Ha'"], 'vsr');

        // insert all 'verbRules' into 'rules'
        Object.keys(verbRules).forEach(function (key) {
            rules[key] = (rules[key] || []).concat(verbRules[key]);
        });
        // insert all 'numRules' into 'rules'
        Object.keys(numRules).forEach(function (key) {
            rules[key] = (rules[key] || []).concat(numRules[key]);
        });
        return rules;
    }


    /*************************************************************************\
    **                                                                       **
    ** Dictionary Loader                                                     **
    **                                                                       **
    \*************************************************************************/
    // Object Anatomy
    // --------------
    // dict = {
    //     "bach": {
    //         pos: "v n",
    //         "v": {
    //                "tlh": "{bach} [1]",
    //                "pos": "verb",
    //                "en": "shoot",
    //                ...
    //         },
    //         "n": {
    //                "tlh": "{bach} [2]",
    //                "pos": "noun",
    //                "en": "shot",
    //                ...
    //         },
    //     },
    //     ...
    // }
    //
    // Usage: loadDictionary(data, dict);
    //
    // Loads 'data', dictionary data in ZDB format, and loads it into the
    // specified 'dict' object.
    //
    // Dictionary data can be loaded from: http://klingonska.org/dict/dict.zdb
    // FIXME: Convert to singleton module pattern
    dict = {};
    function loadDictionary(data, dict) {
        /*jslint white: true */
        var posAbbrev = {
            "adverbial"              : "adv",  "conjunction"        : "conj",
            "exclamation"            : "excl", "name"               : "name",
            "noun"                   : "n",    "noun suffix type 1" : "ns1",
            "noun suffix type 2"     : "ns2",  "noun suffix type 3" : "ns3",
            "noun suffix type 4"     : "ns4",  "noun suffix type 5" : "ns5",
            "numeral"                : "num",  "pronoun"            : "pro",
            "question word"          : "ques", "verb"               : "v",
            "verb prefix"            : "vp",   "verb suffix type 1" : "vs1",
            "verb suffix type 2"     : "vs2",  "verb suffix type 3" : "vs3",
            "verb suffix type 4"     : "vs4",  "verb suffix type 5" : "vs5",
            "verb suffix type 6"     : "vs6",  "verb suffix type 7" : "vs7",
            "verb suffix type 8"     : "vs8",  "verb suffix type 9" : "vs9",
            "verb suffix type rover" : "vsr"
        };
        /*jslint white: false */

        parseZDB(data, function (entry) {
            var tlh = (entry.tlh.match(/\{(.*?)\}/))[1], // Klingon word
                pos = posAbbrev[entry.pos];              // part-of-speech

            // add entry to dictionary
            if (!dict[tlh]) {                  // create empty entry for word
                dict[tlh] = { "tags": [] };
            }
            if (dict[tlh].tags.indexOf(pos) === -1) {
                dict[tlh].tags.push(pos);      //   add part-of-speech
            }
            dict[tlh][pos] = entry;            //   insert actual entry
        });
    }

    /*************************************************************************\
    **                                                                       **
    ** TaggedString Maker                                                    **
    **                                                                       **
    \*************************************************************************/
    // Object Anatomy
    // --------------
    // taggedString = {
    //     text: "Da",            // text
    //     tags: [ "vp", "v" ],   // part-of-speech
    // }
    //
    // 'text' may contain any string (default: ""). 'tags' may contain any number
    // of (being true, or unset). Tags are get/set using array arguments, but
    // only non-existing tags are added (meaning that all tags occur only once).
    //
    // Get Methods
    // -----------
    // obj.getText();
    // obj.getTags() === [ "v", "n" ];   // return all 'tags'
    // obj.getTag(["v", "n"]) === ["n"]; // return all mentioned 'tags'
    // obj.getTag(["v", "n"]) === [];
    // obj.hasTag(["v"]) === true;       // true if any of mentioned 'tags' exist
    // obj.hasTag(["v", "n"]) === true;
    //
    // Set Methods
    // -----------
    // obj.setText("osuchroe") === "socuhoe"
    // obj.setTags([]) === [];
    // obj.setTags(["v"]) === [ "v" ];
    // obj.setTags(["v", "n"]) === [ "v", "n" ];
    //
    taggedStringPrototype = {
        getText: function () { return this.text; },
        setText: function (text, tags) {
            if (text === this.text) { return this; }
            this.text = text;
            this.setTags(tags || []);
            return this;
        },
        addTag: function (tags) {
            if (Object.prototype.toString.call(tags) !== '[object Array]') {
                throw new TypeError("Argument must be array");
            }
            var tagProp = this.tags;
            tags.forEach(function (text) {
                if (tagProp.indexOf(text) === -1) { tagProp.push(text); }
            });
            return this;
        },
        getTags: function (tags) {
            var that = this;
            if (tags === undefined) { return that.tags; }
            if (Object.prototype.toString.call(tags) !== '[object Array]') {
                throw new TypeError("Argument must be array");
            }
            return tags.filter(function (tag) {
                return (that.tags.indexOf(tag) >= 0);
            });
        },
        hasTag: function (tags) {
            if (Object.prototype.toString.call(tags) !== '[object Array]') {
                throw new TypeError("Argument must be array");
            }
            var that = this;
            return tags.some(function (tag) {
                return (that.tags.indexOf(tag) >= 0);
            });
        },
        setTags: function (tags) {
            this.tags = [];
            return this.addTag(tags);
        }
    };
    function makeTaggedString(text, tags) {
        var f = Object.create(taggedStringPrototype);
        return f.setText(text  || "", tags || []);
    }

    /*************************************************************************\
    **                                                                       **
    ** Word Maker                                                            **
    **                                                                       **
    \*************************************************************************/
    // Object Anatomy
    // --------------
    // word = {
    //   "text": "pIqaD",               // unparsed text (original token)
    //   "syllables": [ "pI", "qaD" ],  // text split into syllables
    //   "tags": [ "v", "n" ],          // possible part-of-speech for whole
    //   "parts": [{                    // 1st interpretation ({qaD} = verb)
    //       "root": {
    //         "pos": "v",
    //         "text": "qaD"
    //       },
    //       "parts": [{
    //           "text": "pI",
    //           "pos": "vp"
    //         }, {
    //           "text": "qaD",
    //           "pos": "v"
    //       }]
    //     }, {                         // 2nd interpretation ({pIqaD} = noun)
    //       "root": {
    //         "pos": "n",
    //         "text": "pIqaD"
    //       },
    //       "parts": [{
    //           "pos": "n",
    //           "text": "pIqaD"
    //       }]
    //     }
    //   ],
    //   "roots": {
    //     "qaD"  : [ "v" ],
    //     "pIqaD": [ "n" ]
    //   }
    // }
    //
    // Get Methods
    // -----------
    // All get methods are inherited from taggedString.
    //
    // Set Methods
    // -----------
    // Sets string & recomputes tags.
    //
    // word.setText() -- analyzes and sets the 'syllables' part of the object.
    //
    // word.setTags() is inherited from taggedString.
    //
    wordPrototype = Object.create(taggedStringPrototype);
    (function (that) {
        // split a Klingon word into syllables
        function splitSyllable(word) {
            return word.split(/(?=(?:[bDHjlmnpqQrStvwy\']|ch|gh|ng|tlh)[aeIou])/);
        }

        // Usage: parts = analyzeWord(word, startRules);
        //
        // Splits 'word' into syllables, and analyzes word using the Finite-State
        // Machine (FSM) in 'startRules'. Returned result will be an array of objects
        // containing possible interpretations of the given word.
        //
        // An empty list would mean no possible interpretations. More commonly, would
        // be a result like this (an analysis of the word "bachwI'", which is either a
        // noun + noun suffix {-wI'} <mine> meaning <my short>, or a verb + verb suffix
        // {-wI'} <one who does> meaning <gunner>).
        //
        //     [{
        //             parts: [{           // reference to same value as 'root' below
        //                     pos: 'v',
        //                     text: "bach",
        //                 }, {
        //                     pos: 'vs',
        //                     text: "wI'",
        //             }],
        //             root: {
        //                 pos: 'v',
        //                 text: "bach",
        //             },
        //         }, {
        //             parts: [{           // reference to same value as 'root' below
        //                     pos: 'n',
        //                     text: "bach",
        //                 }, {
        //                     pos: 'ns',
        //                     text: "wI'",
        //             }],
        //             root: {
        //                 pos: 'n',
        //                 text: "bach",
        //             },
        //     }]


        function analyzeWord2(wordQ) {
            var wordObj  = wordQ.shift(),          // word object to analyze
                syllable = wordObj.queue[0],       // syllable to process
                rules    = wordObj.rules,
                newQueue = wordObj.queue.slice(1); // remaining syllables
            rules[syllable].forEach(function (state) {
                var pos      = state.tag || '',
                    newRules = state.rules,
                    newParts = wordObj.parts.slice(0),
                    newRoot  = wordObj.root,
                    lastPart;
                if (isRoot[pos]) {
                    newRoot = {
                        'pos' : pos,
                        'text': (wordObj.root ? wordObj.root.text : '') + syllable
                    };
                    lastPart = newParts.length - 1;
                    if (newParts[lastPart] && newParts[lastPart].pos === '') {
                        newParts[lastPart] = newRoot;
                    } else {
                        newParts.push({'text': syllable, 'pos': pos });
                    }
                } else {
                    newParts.push({'text': syllable, 'pos': pos });
                }
                if (newQueue.length) { // add next to queue
                    wordQ.push({
                        'parts': newParts,
                        'queue': newQueue,
                        'root' : newRoot,
                        'rules': newRules
                    });
                } else {
                    if (newRoot.pos) { // if part-of-speech of root is set
                        result.push({  //   save this word to result
                            'parts': newParts,
                            'root' : newRoot
                        });
                    }
                }
            });


            if (wordQ.length) { return analyzeWord2(); }
        }

        function analyzeWord(syllables, startRules) {
            var wordObj, syllable, rules, newQueue, result = [],
                wordQ = [{  // modifiable
                    'parts': [],
                    'queue': syllables,
                    'root' : null,
                    'rules': startRules
                }];
            return analyzeWord2(wordQ);

            function xxx(rules, wordObj, syllable, newQueue) {
                if (!rules) { return; }
                rules.forEach(function (state) {
                    var pos      = state.tag || '',
                        newRules = state.rules,
                        newParts = wordObj.parts.slice(0),
                        newRoot  = wordObj.root,
                        lastPart;
                    if (isRoot[pos]) {
                        newRoot = {
                            'pos' : pos,
                            'text': (wordObj.root ? wordObj.root.text : '') + syllable
                        };
                        lastPart = newParts.length - 1;
                        if (newParts[lastPart] && newParts[lastPart].pos === '') {
                            newParts[lastPart] = newRoot;
                        } else {
                            newParts.push({'text': syllable, 'pos': pos });
                        }
                    } else {
                        newParts.push({'text': syllable, 'pos': pos });
                    }
                    if (newQueue.length) { // add next to queue
                        wordQ.push({
                            'parts': newParts,
                            'queue': newQueue,
                            'root' : newRoot,
                            'rules': newRules
                        });
                    } else {
                        if (newRoot.pos) { // if part-of-speech of root is set
                            result.push({  //   save this word to result
                                'parts': newParts,
                                'root' : newRoot
                            });
                        }
                    }
                });
            }

            while (wordQ.length) {
                wordObj  = wordQ.shift();          // word object to analyze
                syllable = wordObj.queue[0];       // syllable to process
                rules    = wordObj.rules;
                newQueue = wordObj.queue.slice(1); // remaining syllables

                // ruleList = rules[syllable];
                // for (key in ruleList) {
                //     if (ruleList.hasOwnProperty(key)) {
                //         rule = ruleList[key];


                //     }
                // }

                xxx(rules[syllable], wordObj, syllable, newQueue);
            }
            return result;
        }
        that.getSyllable = function (start, length) {
            return this.syllables.slice(start, length).map(function (x) {
                return x.text;
            });
        };
        that.addRoot = function (word, pos) {
            var tagProp;
            if (Object.prototype.toString.call(pos) !== '[object Array]') {
                throw new TypeError("Argument must be array");
            }
            if (!this.roots) { this.roots = {}; }
            if (!this.roots[word]) {           // set (if unset)
                this.roots[word] = pos;
            } else {                           // add to existing values
                tagProp = this.roots[word];
                pos.forEach(function (pos) {
                    if (tagProp.indexOf(pos) === -1) { tagProp.push(pos); }
                });
            }
        };
        that.setText = function (text) {
            var word = this;
            if (text === word.text) { return word; } // skip if unchanged
            word.text      = text;
            word.syllables = splitSyllable(text);
            word.parts     = analyzeWord(word.syllables, wordRules);
            word.setTags(word.parts.map(function (part) {
                return isPos[part.parts[part.parts.length - 1].pos];
            }));
            word.roots = {};
            word.parts.forEach(function (part) {
                word.roots[part.root.text] = [part.root.pos];
            });
            return word;
        };
    }(wordPrototype));
    function makeWord(text, tags) {
        var f = Object.create(wordPrototype);
        return f.setText(text  || "", tags || []);
    }

    /*************************************************************************\
    **                                                                       **
    ** Main Program Functions                                                **
    **                                                                       **
    \*************************************************************************/
    function tmpOutput(msg) {
        clearTimeout(clearTimer);
        outputElement.html(msg);
        clearTimer = setInterval(function () {
            outputElement.html('');
        }, 1500);
    }

    function output(msg) {
        clearTimeout(clearTimer);
        outputElement.html(msg);
    }

    function analyzeSpace(text) {
        if (text.match(/[.!?]/)) {             // full stop
            return 'sf';                       //   separator, full stop
        }
        if (text.match(/[,;:()]/)) {           // half stop
            return 'sh';                       //   separator, half stop
        }                                      // space
        return 'ss';                           //   separator, space
    }

    tlhSortkey = (function () {
        /*jslint white: true */
        var transl = {
            "a"  : "a",   "b" : "b",   "ch": "c",   "D" : "d",   "e" : "e",
            "gh" : "f",   "H" : "g",   "I" : "h",   "j" : "i",   "l" : "j",
            "m"  : "k",   "n" : "l",   "ng": "m",   "o" : "n",   "p" : "o",
            "q"  : "p",   "Q" : "q",   "r" : "r",   "S" : "s",   "t" : "t",
            "tlh": "u",   "u" : "v",   "v" : "w",   "w" : "x",   "y" : "y",
            "'"  : "z"
        };
        /*jslint white: false */
        // split a Klingon word into characters (doesn't cope with puncuation)
        function splitCharacter(word) {
            return word.split(/(?=[abDeHIjmnopqQrStuvwy\']|[cg]h|ng|tlh|l(?!h))/);
        }
        return function (word) {
            return splitCharacter(word).map(function (character) {
                return transl[character] || '';
            }).join('');
        };
    }());

    // sorting function, use `array.sort(byKlingon)` to sort in Klingon
    // alphabetical order
    function byKlingon(a, b) {
        var x = tlhSortkey(a), y = tlhSortkey(b);
        if (x < y) { return -1; }
        if (x > y) { return 1; }
        return 0;
    }

    function analyze(lang) {
        var glossary  = {}, tokens, html,
            // read input & convert unicode apostrophes to ascii
            text      = inputElement.text().replace(/[\u2018\u2019]/g, "'"),
            splitted  = text.split(/([^a-z\']+)/i),  // split into tokens
            wordCount = 0;

        // process tokens (= word or inter-word space)
        tokens = splitted.map(function (text) {
            if (text.match(/^[a-z\']/i)) {     // word
                wordCount += 1;
                return makeWord(text);
            }                                  // punctuation
            return makeTaggedString(text, [ analyzeSpace(text) ]);
        });
        $('#textcount').html(wordCount);

        // glossary = {
        //     "bach": {
        //         text: "bach",
        //         tags: [ "n", "v" ],
        //         count: 2
        //     },
        // }
        //
        // go through processed tokens, generate glossary
        tokens.forEach(function (wordObject) {
            if (wordObject.parts) {
                wordObject.parts.forEach(function (part) {
                    var root = part.root,
                        tag  = root.pos,
                        text = root.text;
                    if (glossary[text]) {          //   already existing word
                        glossary[text].addTag([tag]);
                        glossary[text].count += 1;
                    } else {                       //   new word
                        glossary[text] = makeTaggedString(text, [tag]);
                        glossary[text].count = 1;
                    }
                });
            }
        });
        //alert(JSON.stringify(glossary, null, 2));

        // go through processed tokens, generate HTML output
        html = tokens.map(function (obj) {
            var title;
            if (!obj.parts) {              // space and/or punctuation
                return '<span title="' + obj.pos + '"><span>' + obj.text + '</span></span>';
            }                                  // a word
            title = obj.parts.map(function (part) {
                return part.parts.map(function (part) {
                    return part.text + '(' + part.pos + ')';
                }).join('&ndash;');
            });
            //return '<span class="' + obj.getTags().join(' ') + '" title="' + title + '">' +
            return '<span class="' + obj.getTags().join(' ') + '" title="' +
                'Part of Speech: ' + (obj.getTags().join(', ') || 'N/A') + '\n' +
                'Breakdown:\n    ' + (title.join('\n    ') || 'N/A') + '\n' +
                JSON.stringify(obj, null, 4).replace(/\"/g, '&quot;') + '">' +
                '<span>' + obj.getText() + '</span></span>';
        }).join('');

        inputElement.html(html);
        // output glossary
        output('<table class="sortable">' +
            '<thead><tr><th><th>Klingon<th>Pos<th>' +
            '<span class=unzap title="Undo word remove.">↶</span>English</thead>' +
            '<tbody>' +
            Object.keys(glossary).sort(byKlingon).map(function (key) {
                var obj = glossary[key], text = obj.text,
                    tags = obj.tags, count = obj.count;
                return tags.map(function (tag) {
                    var prettyText = text.replace(/\'/g, '&rsquo;');
                    return '<tr class=' + tag + '>' +
                        '<td align=center>' + count + '</td>' +
                        '<td sorttable_customkey="' + tlhSortkey(text) + '">' +
                        '<b lang=tlh>' + prettyText + '</b></td>' +
                        '<td align=center>' + tag + '</td>' +
                        '<td><span class=zap title="Remove this word.">×</span>' +
                        (dict[text] ? dict[text][tag][lang] : 'N/A') +
                        '</td>' +
                        '</tr>';
                }).join('');
            }).join('') +
            '</tbody>' +
            '</table>' +
            '<script src="../includes/sorttable.js"></script>' +
            '<script src="zaptablerow.js"></script>');
    }
    function analyze_en() { analyze('en'); }
    function analyze_sv() { analyze('sv'); }

    /*************************************************************************\
    **                                                                       **
    ** On Page Ready                                                         **
    **                                                                       **
    \*************************************************************************/
    $(document).ready(function () {
        outputElement = $('#output');
        inputElement  = $('#input');
        $('button[lang|=en]').click(analyze_en);   // connect 'Analyze' button to function
        $('button[lang|=sv]').click(analyze_sv);   // connect 'Analyze' button to function
        $('#input').focus();          // focus input area

        // load dictionary data
        $.get('../dict/dict.zdb', function (data) {
            wordRules = getRules(data);
            loadDictionary(data, dict);
            tmpOutput('<a href="../dict/dict.zdb">Dictionary</a> loaded.');
            //output('<pre>' + JSON.stringify(dict, null, 4) + '</pre>');
        });
    });


}(document)); // passed in for minifying purposes


/*****************************************************************************\
**                                                                           **
** Page Language Selector                                                    **
**                                                                           **
\*****************************************************************************/

// This should be used with a <select class=lang> on your page. An onChange
// event is added to that, which, on selection sets 'data-lang' of the <html>
// attribute, so that you may use CSS to show/hide various elements on the
// page.
(function (document) {
    'use strict';
    // set 'data-lang' attribute of <html> element
    function setLang(lang) {
        $(document.body).attr('data-lang', lang);
    }
    $(document).ready(function () {
        setLang('en');  // default langue = english
        // call language change whenever user changes <select class=lang>
        $('select.lang').change(function () { setLang(this.value); });
    });
}(document));

//eof

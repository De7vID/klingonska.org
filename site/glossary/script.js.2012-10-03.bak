//
// FIXME: Put the HTML/DOM stuff back using the callback
//

// create one HTML tag
function tag(tag, content, attr) {
     content = content || '';
     return '<' + tag + (attr ? ' ' + attr : '') + '>' +
         content + '</' + tag + '>';
}

function log(str) {
    $('#log').append('<br>&gt;' + str);
}

function dump(someArray) {
    $('#dump').html(
        tag('pre', JSON.stringify(someArray, null, 4)) +
        tag('p', 'Length: ' + someArray.len())
    );
}

// sort() function
function by(field, reverse, primer) {
    'use strict';
    var key = primer ?
        function (x) { return primer(x[field]); } :
        function (x) { return x[field]; }
    return function (a, b) {
        var A = key(a), B = key(b);
        return  (A < B ? -1 :
                (A > B ?  1 : 0)) * [1,-1][+!!reverse];
    }
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// FIXME: Maybe make an array kind of object out of this thingy. Probably use
// method described in "Wrappers. Prototype chain injection." method of
// [http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/]
//

//
// Usage: $obj = makeLiveArray(<CALLBACK>);
//
// Creates an array. Whenever array content is modified <CALLBACK> is invoked,
// if it returns false, the change will be denied (and the denied method will
// return 'false'). If it returns true, changes are made. (<CALLBACK> may also
// invoke secondary effects, e.g. updating of stuff in the DOM, or similar.)
//
// CALLBACK INVOKATION:
//
//     onChangeCallback(startIndex, removeValues, addValues);
//
// Callback is passed the index of the first element modified, a list of values
// about to be removed from the array, and a list of values about to be
// inserted. If values are only inserted (i.e. no values are deleted from the
// original list by the operation) then `removeValues` is an empty list. If
// values are only deleted (i.e. no new values are inserted) then `addValues`
// will be an empty list.
//
// If both `removeValues` and `addValues` are empty lists, then the callback
// will not be invoked at all, and no change will be made.
//
// CAVEAT
//
// When using the 'sort' and 'reverse' methods the callback will be passed with
// the entire array as arguments (i.e. the entire old array as `removeValues`
// and the entire sorted/reversed array as `newValues`) -- You may still use
// the callback return value to abort the sort/reverse.
//
// METHODS
//
//   thingy.onChange([CALLBACK]); -- change (or remove) the callback used
//
function makeLiveArray(callback) {
    var object = {};
    if (callback && typeof callback !== 'function') {
        throw new TypeError('makeLiveArray() argument must callback function');
    }
    // create javascript interface for object
    // (prototype created when first called, later calls reuse first one)

    makeLiveArray.prototype = new Array;

    if (!makeLiveArray.tableArrayPrototype) { // on first invokation
        makeLiveArray.tableArrayPrototype = { //   create prototype w/ methods
            'len': function () { return this.contents.length; },
            'set': function () { alert('not yet implemented'); },
            'get': function () { alert('not yet implemented'); },
            sort: function () {
                var array  = this.contents,
                    values = [].sort.apply(array.concat(), arguments);
                if (this.callback(0, array, values)) { return this.contents = values; }
            },
            reverse: function () {
                var array  = this.contents,
                    values = [].reverse.apply(array.concat(), arguments);
                if (this.callback(0, array, values)) { return this.contents = values; }
            },
            splice:  function (index, howMany, values) {
                var array = this.contents, length = array.length,
                    max, result, old = [];
                // fix incoming values
                if (values === undefined) { values = []; }
                if (index > length) { index = length; }
                if (index < 0) {
                    index = length + index;
                    if (index < 0) { index = 0; }
                }
                max = length - index;
                if (howMany === undefined || howMany > max) { howMany = max; }
                // cancel if no change
                if (howMany === 0 && values.length === 0) { return []; }
                // invoke callback
                if (howMany > 0) { old = array.slice(index, index + howMany); }
                if (this.callback(index, old, values)) {
                    return array.splice.apply(array, [index, howMany].concat(values));
                }
            },
            push:     function (values) { return this.splice(this.len(), 0, values) && this.len(); },
            pop:      function ()       { return this.splice(-1);                    },
            shift:    function ()       { return this.splice( 0, 1);                 },
            unshift:  function (values) { return this.splice( 0, 0, values) && this.len(); },
            onChange: function (callback) {
                this.callback = callback || function () { return true; };
                return this;
            }
        };
    }
    // create object instance & insert user specified options in it
    object = Object.create(makeLiveArray.tableArrayPrototype);
    object.contents = [];
    object.onChange(callback);
    return object;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function changed(index, oldValues, newValues) {
    log(tag('pre', 'index: ' + index +
          '\nremoved: ' + JSON.stringify(oldValues, null, 4) +
          '\nadded: '   + JSON.stringify(newValues, null, 4) + '\n\n'
    ));
    return true;
}

var thingy = makeLiveArray(changed);
thingy.push([
    { tlh: 'bach', pos: 'n', en: 'shot'  },
    { tlh: 'bach', pos: 'v', en: 'shoot' }
]);

thingy.onChange(changed);

dump(thingy);

// eof

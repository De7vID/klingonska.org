#!/usr/bin/perl -w
use strict;
use 5.10.0;

# enable UTF-8
use utf8;
binmode(STDIN,  ":encoding(utf8)");
binmode(STDOUT, ":encoding(utf8)");
binmode(STDERR, ":encoding(utf8)");

if (-t STDIN and @ARGV == 0) {
    print <<"EOF";
Usage: $0 [<] FILE
Perform various syntax/consistency checks of a the KA dictionary.
EOF
    exit;
}

=pod

=head1 TODO

* Check that all homonymous words have an enumeration (1) etc in 'tlh' field
* Email should require "by", "to" and a subject in parentheses.
* check_tlh() -- TKD talks about "uw" -- and some other letter combination? --
  being disallowed in Klingon: insert test for that, too, here
* Text fields should not be allowed to end in comma, space, colon or semicolon

=cut

my %cfg = (
    canon_path     => "../../canon", # relative to this file's path
    field_order    => [ qw(tlh warn pos sv en desc def ref com pun see cat data file) ],
    field_required => [ qw(tlh pos sv en def file) ],
    field_subs     => {
        tlh  => \&check_tlh,
        warn => \&check_warn,
        pos  => \&check_pos,
        en   => \&check_en,
        sv   => \&check_sv,
        def  => \&check_source,
        ref  => \&check_source,
        see  => \&check_see,
        data => \&check_data,
        file => \&check_file,
    },
);

# absolutify path to canon files
$cfg{canon_path} = do {
    use Cwd 'realpath';             # scripts absolute name
    my $script = realpath($0);
    use File::Spec 'splitpath';     # dir part of scripts name
    my ($volume, $scriptdir) = File::Spec->splitpath($script);
    realpath($scriptdir . "/" . $cfg{canon_path});
};


my %pos_en = (
    v    => 'verb',
    n    => 'noun',
    name => 'name',
    adv  => 'adverbial',
    conj => 'conjuction',
    excl => 'exclamation',
    num  => 'numeral',
    pro  => 'pronoun',
    ques => 'question word',
    ns1  => 'noun suffix type 1',
    ns2  => 'noun suffix type 2',
    ns3  => 'noun suffix type 3',
    ns4  => 'noun suffix type 4',
    ns5  => 'noun suffix type 5',
    vp   => 'verb prefix',
    vsr  => 'verb suffix type rover',
    vs1  => 'verb suffix type 1',
    vs2  => 'verb suffix type 2',
    vs3  => 'verb suffix type 3',
    vs4  => 'verb suffix type 4',
    vs5  => 'verb suffix type 5',
    vs6  => 'verb suffix type 6',
    vs7  => 'verb suffix type 7',
    vs8  => 'verb suffix type 8',
    vs9  => 'verb suffix type 9',
);

my %pos_sv = (
    v    => 'verb',
    s    => 'noun',
    namn => 'name',
    adv  => 'adverbial',
    konj => 'conjuction',
    interj => 'exclamation',
    'räkn' => 'numeral',
    pro  => 'pronoun',
    'fråg' => 'question word',
    ss1  => 'noun suffix type 1',
    ss2  => 'noun suffix type 2',
    ss3  => 'noun suffix type 3',
    ss4  => 'noun suffix type 4',
    ss5  => 'noun suffix type 5',
    vp   => 'verb prefix',
    vss  => 'verb suffix type rover',
    vs1  => 'verb suffix type 1',
    vs2  => 'verb suffix type 2',
    vs3  => 'verb suffix type 3',
    vs4  => 'verb suffix type 4',
    vs5  => 'verb suffix type 5',
    vs6  => 'verb suffix type 6',
    vs7  => 'verb suffix type 7',
    vs8  => 'verb suffix type 8',
    vs9  => 'verb suffix type 9',
);


###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

my %record = read_dict();

fields_ok(@cfg{qw(field_required field_order field_subs)}, %record);


# check sort order in dictionary
# FIXME each section should be tested in its own
my $last_sortkey = "";
my $last_word    = "";
my ($prefix_count, $suffix_count, $word_count, $marked_count) = (0, 0, 0, 0);
foreach my $line (sort { $a <=> $b } keys %record) {
    my $_ = $record{$line};

    if (my ($marked, $word) = /^tlh:\t(\*?)\{(.*)\}/m) {
        $marked_count ++ if $marked;
        given ($word) {
            when (/-$/) { $prefix_count ++ }
            when (/^-/) { $suffix_count ++ }
            default { $word_count ++ }
        }
        my $sortkey = sortkey_tlh($word);
        my $order = ($last_sortkey cmp $sortkey);
        if ($order == 1) {
            warn "wrong sort order: {$last_word} comes before {$word}, in record at line $line\n";
        }
        $last_sortkey = $sortkey;
        $last_word    = $word;
    }
}
warn "Word count: $word_count (" .
    "prefixes: $prefix_count, " .
    "suffixes: $suffix_count, " .
    "marked: $marked_count)\n";
exit;


sub sortkey_tlh {
    my ($_) = @_;
    # %alph{klingon_letter} = sort_key
    my %alph = (
        a   => 'a',   b => 'b',   ch => 'c',   D => 'd',   e => 'e',
        gh  => 'f',   H => 'g',   I  => 'h',   j => 'i',   l => 'j',
        m   => 'k',   n => 'l',   ng => 'm',   o => 'n',   p => 'o',
        q   => 'p',   Q => 'q',   r  => 'r',   S => 's',   t => 't',
        tlh => 'u',   u => 'v',   v  => 'w',   w => 'x',   y => 'y',
        "'" => 'z',
    );

    # prefix/suffix?
    my $pre = "a";
    $pre = "b" if s/-$//; # prefix (ending with "-")
    $pre = "c" if s/^-//; # suffix (beginning with "-")

    # strip non-alphabetical chars
    s/[^a-zA-Z']//g;

    # replace alpha chars with sourt count
    my $re1 = join("|", sort keys %alph);
    #print $re1, "\n";
    s{($re1)(?=($re1)*$)}{ $alph{$1} }eg;

    # insert prefix/suffix/word
    $_ = $pre . "-" . $_;

    return $_;
}


###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub TRUE  {  1 }
sub FALSE { '' }

sub numerically { $a <=> $b }

sub check_en {
    my ($_, $field, $record) = @_;
    if (/\((v|n|name|adv|conj|excl|num|pro|ques|ns[1-5]|vp|vs[1-9r])\)/m) {
        warn "part-of-speech '($1)' must not be given inside '$field' field\n";
        print STDERR "    $field: $_\n";
    }
    {
        # «...» or <...> are required except for affixes
        if (!/[«<]/ and $record !~ /^pos:.*\b(suf|pre)fix\b/m) {
            warn "missing «...» or <...> brackets in '$field' $field\n";
            print STDERR "    $field: $_\n";
        }
    }
    {
        # check for matching <...>
        my $bra = () = m/</g;
        my $ket = () = m/>/g;
        warn "mismatched <...> brackets ($bra open, $ket close) in '$field' field\n"
            if $bra != $ket;

    }
    {
        # check for matching «...»
        my $bra = () = m/«/g;
        my $ket = () = m/»/g;
        warn "mismatched «...» brackets ($bra open, $ket close) in '$field' field\n"
            if $bra != $ket;
    }
}

sub check_see {
    my ($_, $field, $record) = @_;
    if (my ($tlh) = $record =~ /^tlh:\t.*(\{.*})/) {
        warn "Reference '$_' points to itself '$field' field\n"
            if /$tlh/;
    } else {
        warn "Counldn't find a (Klingon) word within curly brackets in field 'tlh'\n";
    }
}

sub check_data {
    my ($_, $field, $record) = @_;
    if (/^data:\t.*\b(deprecated|non-canon)\b/) {
        warn "when 'data' field contains 'deprecated' or 'non-canon', 'tlh' must have leading asterisk\n"
            if not $record =~ /^\*/m
    }
}

sub check_file {
    my ($_, $field, $record) = @_;
    foreach (split("; ", $_)) {
        my $abs = "$cfg{canon_path}/$_";
        my $rel = File::Spec->abs2rel($abs);
        warn "non-existant file '$rel' in 'file' field\n"
            unless -e $abs;
    }
}

sub check_pos {
    my ($_, $field) = @_;
    my $re = qr{
        verb(\s(prefix|suffix\stype\s([1-9]|rover)))?|
        noun(\ssuffix\stype\s[1-5])?|
        name|adverbial|conjuction|exclamation|numeral|pronoun|question\sword
    }x;
    if (not /^($re)$/) {
        warn "invalid part-of-speech in '$field' field\n";
        print STDERR "    $field: $_\n";
    }
}

# used for both 'def' and 'ref'
sub check_source {
    my ($_, $field) = @_;
    if (not source_ref_syntax($_)) {
        warn "invalid source reference in '$field' field\n";
        print STDERR "    $field: $_\n";
    }
}

sub check_sv {
    my ($_, $field, $record) = @_;
    if (/\((v|s|namn|adv|konj|interj|räkn|pro|fråg|ss[1-5]|vp|vs[1-9]s)\)/m) {
        warn "part-of-speech '($1)' must not be given inside '$field' field\n";
        print STDERR "    $field: $_\n";
    }
    {
        # «...» are required except for affixes
        if (!/«/ and $record !~ /^pos:.*\b(suf|pre)fix\b/m) {
            warn "missing «...» brackets in '$field' $field\n";
            print STDERR "    $field: $_\n";
        }
    }
    {
        # <...> are not allowed
        if (/</) {
            warn "<...> brackets are not allowed in '$field' $field\n";
            print STDERR "    $field: $_\n";
        }
    }
    {
        # check for matching «...»
        my $bra = () = m/«/g;
        my $ket = () = m/»/g;
        warn "mismatched «...» brackets ($bra open, $ket close) in '$field' field\n"
            if $bra != $ket;
    }
}

sub check_tlh {
    my ($_, $field, $record) = @_;
    my $re = qr/([bDHjlmnpqQrStvwy']|ch|gh|ng|tlh)[aeIou]([bDHjlmnpqQrStv']|ch|gh|ng|tlh|[wy]'?|rgh)?/;
    if (not /^\*?\{($re+(\s$re+|\s«($re+|pIqarD)»)*|$re?-|-$re|-oy|qIrq)\} ( \s \([0-9]+\) )? $/x) {
        # TKD talks about "uw" -- and some other letter combination? -- being
        # disallowed in Klingon: insert test for that, too, here
        warn "bad syllable structure in '$field' field\n";
        print STDERR "    $field: $_\n";
    }

    if (/^\*/) {
        warn "with leading asterisk in 'tlh' field 'warn' field must be present\n"
            if not $record =~ /^warn:\t/m;
        warn "with leading asterisk in 'tlh' field 'see' field must be present\n"
            if not $record =~ /^see:\t/m;
        warn "with leading asterisk in 'tlh' field 'data' field must contain 'deprecated' or 'non-canon'\n"
            if not $record =~ /^data:\t.*\b(deprecated|non-canon)\b/m;
    }
}

sub check_warn {
    my ($_, $field, $record) = @_;
    warn "leading asterisk is required in 'tlh' field when '$field' field is present\n"
        if not $record =~ /^tlh:\t\*/;
}

# Usage: %RECORD = read_dict();
#
# Reads all records from a zdb file into %RECORD. Keys of the hash will be the
# line number each record started at. Values will be the complete content of
# the record (with any continuation lines unwrapped).
#
sub read_dict {
    # skip header
    while (<>) {
        last if /^=== start-of-word-list ===$/;
    }

    # read file up to footer (ignoring section separators)
    my $line   = -1;
    my %record = ();
    while (<>) {
        /^=== end-of-noun-suffix-list ===$/ and last;
        /^=== / and next;
        /^$/ and $line = -1, next;

        if (/^[^:\s]*:/) {                  # new field
            if ($line == -1) {              #   if 1st in record
                $line = $.;                 #     remember line
                $record{$line} = "";        #     init record value
            }
        } elsif (s/^\t+/ /) {               # continuation line
            chomp($record{$line});          #   strip previous newline
        }
        $record{$line} .= $_;               # append value to record
    }

    return %record;
}

# Usage: BOOL = fields_ok(\@REQUIRED, \@ORDER, \%SUBS, %RECORD);
#
# Checks the order and existance of field names in %RECORD, warn()s if any
# problems were found. Returns true if no warnings were outputted, FALSE
# otherwise.
#
# \@REQUIRED is a reference to a list containing the names of the required
# fiels (in no particular order).
#
# \@ORDER is a reference to a list containing the names of all allowed fields
# in the order which they must occur within a record.
#
# \%SUBS is a reference to a hash containing check functions for specified
# named fields. (Fields for which there exist no check function is assumed to
# be valid as-is.)
#
# Field names to be checked are the keys, values are coderefs for functions
# called to check the field content. Each code reference is called with the
# following arguments (1) the content of the field (2) name of the field and
# (3) the complete content of the record. Within the check function, call
# warn() with the appropriate error message for each detected problem. Only if
# warn() never was called does fields_ok() return true.
#
# %RECORD should contain dict-type records as values, and with their line
# numbers (in the original file) as keys. The keys of %RECORD are not tested in
# any way, only outputted as a hint to the user of where (in the source file) a
# problem was found.
#
sub fields_ok {
    my ($field_required, $field_order, $field_subs, %record) = @_;
    my $result = TRUE;

    my $field_subs_re = do {
        my $x = join("|", sort keys %$field_subs);
        qr/$x/ if $x;
    };

    # field name -> field number hash
    # (used to check that fields come in right order within record)
    my %field_number = do {
        my $count = 1;
        map { $_ => $count++ } @$field_order;
    };

    # check fields
    foreach my $line (sort numerically keys %record) {
        my $_ = $record{$line};  # record content

        local $SIG{__WARN__} = sub {
            chomp(my @x = @_);
            $result = FALSE;
            warn "@x, in record at line $line\n";
        };

        # check that required fields exist
        foreach my $field (@$field_required) {
            if (not /^$field:\t/m) {
                warn "missing required field '$field'\n";
            }
        }

        # check field order
        my $num = -1;
        while (/^([^:\s]*):/gm) {
            my $field = $1;
            if (not exists($field_number{$field})) {
                warn "unknown field '$field'\n";
                next;
            }
            if ($field_number{$field} < $num) {
                warn "field '$field' is too late in field order\n";
                next;
            }
            $num = $field_number{$field};
        }


        if ($field_subs_re) {
            while (/^($field_subs_re): \t (.*) /gmx) {
                $field_subs->{$1}($2, $1, $_);
            }
        }

    }

    return $result;
}

sub source_ref_syntax {
    my ($_) = @_;
    my $s  = qr/[  ]/x;                                     # spaces
    my $p  = qr/[ivx]+|\d+/x;                               # a page number
    my $pp = qr/ p\.$p | pp\.$p(--$p|(,$s$p(--$p)?)+) /x;   # p.#PAGE or pp.#RANGE

    my $chapter  = qr/[0-9]+(\.[0-9]+)+ ($s\($pp\))?/x;     # CHAPTER [ (PAGE) ]
    my $chapters = qr/$s$chapter(,$s$chapter)*/x;           # CHAPTER [ (PAGE) ], ...

    # page numbers, chapter numbers, 'E-K' or 'K-E'
    my $tkd_ref  = qr/(K-E|E-K|$chapter|$pp)/x;             #
    my $tkd_refs = qr/ $s $tkd_ref(, $s $tkd_ref)*/x;       #

    # page numbers, 'E-K' or 'K-E'
    my $kgt_ref  = qr/(K-E|E-K|$pp)/x;
    my $kgt_refs = qr/ $s $kgt_ref(, $s $kgt_ref)*/x;

    # simple page numbers
    my $page_refs = qr/ $s $pp(, $s $pp)*/x;

    my $paged_source   = qr/( TKDa? $tkd_refs? |KGT $kgt_refs? | (DI|Eurotalk|Sarek|TKW|HQ[0-9]+:[0-9]+) $page_refs?) (${s}et${s}al\.)? /x;
    my $unpaged_source = qr/BoP|CK|PK|KCD|KLINW|TDNW|Radio $s Times|
                            S7|S8|S14|S15|S20|S25|S26|S32|S33|ST5|STE|
                            ST1|
                            \{qep'a'\}$s\d{4}|(News|Email|Web) $s [0-9]{4}-[0-9]{2}-[0-9]{2} ($s \(.*?\))?/x;

    my $source       = qr/ $paged_source|$unpaged_source /x;


    return /^ $source (;$s$source)* $/x ? TRUE : FALSE;
}


# foreach my $num (sort { $a <=> $b } keys %record) {
#     print "=" x 80, "\n",
#         "==  $num\n",
#         "$record{$num}";
# }

#[eof]

#!/bin/zsh
#
# thumbify - generate thumbs for pictures
#
# [2004-11-04, 09.32-09.41] [2004-11-04, 10.49-14.34] [2004-11-05, 14.21-17.53]
# [2004-11-05, 18.49-19.18] [2003-11-13, 12.08-12.31]
#
# [2005-05-24, 09.42-13.16] implemented height/width in html output of inlined
# images, implemented --html-only option, started writing .thumbifyrc reading
# but gave up (found bugs in zsh which must be worked around)
#
# [2005-11-10, 19.43-19.50] now works on symlinks too
#
# [2010-11-12, 19:31-19:42] modified default settings to fit for klingonska.org
#
# TODO:
#   o better note whether a thumbnail is really a thumbnail?
#     (look at file age compared to it's image? look at it's image's extension?
#     add an image comment noting it as a thumbnail?)
#   o avoid scaling up small images (warn instead)
#   o read defaults from .thumbifyrc-file
#     (preferably containing several profiles, depending on glob matching pwd)
#   o read defaults from a file in the same directory
#


###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

# defaults
HEIGHT=250              #
WIDTH=250               #
FORMAT='jpeg'           # output file format = jpeg
RCFILE='.thumbifyrc'    # name of rc file
PREFIX=''               # filename prefixing = off
SUFFIX='.thmb'          # add to filename ('hello.jpg' -> 'hello.thmb.jpg')
VERBOSE=''              # verbose output     = off
HTML_OUTPUT=''          # html output        = off
HTML_OUTPUT_ONLY=''     # html output only   = off (i.e. no thumb creation)
QUIET=''                # don't be quiet
FORCE=''

typeset -A extension    # file extentensions when different
extension=(             #   from output format name
    jpeg jpg            #
)                       #



###############################################################################
##                                                                           ##
##  Informational Functions                                                  ##
##                                                                           ##
###############################################################################


help() {                                       # -h, --help
    cat <<END-OF-HELP                          #
Usage: $EXE [OPTION] FILE...
Generate a thumbnail image for each FILE.

  -f, --force          make thumbnails for *all* images (even thumbnails)
  -h, --help           display this help and exit
      --html           show HTML tags on STDOUT (suppresses --verbose)
      --html-only      do not generate thumbnails, only output HTML
  -o, --output=TYPE    output file format (default: $FORMAT)
  -q, --quiet          suppress error messages
  -p, --prefix=WORD    add WORD to beginning of each thumbnail filename
  -s, --suffix=WORD    add WORD to end of each thumbnail filename
  -t, --types          list possible output TYPEs
  -v, --verbose        output names of processed files
  -x, --width=PIXELS   max width of thumbnails (default: $WIDTH)
  -y, --height=PIXELS  max height of thumbnails (default: $HEIGHT)
                       (image aspect is always retained)

Thumbnail file names are generated by adding prefix WORD at beginning of
original file name and/or by adding the suffix word just before the file
extension (i.e. '.jpg' or whatever).

Thumbs are generated by scaling down images to the largest possible size that
fits inside a box of the specified height/width.
END-OF-HELP
    exit                                       #
}                                              #


types() {                                      # -t, --types
    echo "The following image output types are available:"
    echo                                       #
    types=()                                   #
    foreach DIR in $path; do                   #   foreach dir in $PATH
        types=($types $DIR/(pnm|ppm)to*(N))    #     list all ppmtoTYPE and
    done                                       #       pnmtoTYPE programs
    foreach FILE in $types; do                 #   output list, stripped
        echo "    ${FILE##([^/]#/)#p[np]mto}"  #     of path and `pnmto' or
    done | sort | uniq | column                #     `ppmto' part of command
    cat <<END-OF-TEXT                          #

This script relies on the executables from the netpbm-suite for file conversion
and scaling. Hence it is able to output images in any format for which you have
a 'ppmtoTYPE' or 'pnmtoTYPE' command (in your \$PATH). The above list is
automatically produced from the currently available commands.
END-OF-TEXT
    exit
}


###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################


# output error message on standard error
# (exits if given shell exit status as 2nd arg)
ERRORS=0
error() {                                      #
    [[ -n $1 && -z $QUIET ]] &&                # output error any message
        echo "$EXE: $1" >&2                    #   unless in QUIET mode
    [[ $2 -eq 1 && -z $QUIET ]] &&             #   more info on exit status 1
        echo "Try '$EXE --help' for more information." >&2 #'"
    [[ -n $2 ]] && exit $2                     # exit if given exit status
    ((ERRORS++))                               # count errors
}


# Usage: html_output IMAGEFILE THUMBFILE
# (Returns HTML on STDOUT. HTML consists of an inlined image [THUMBFILE -- with
# "height" and "width" tags set appropriately] linked to IMAGEFILE.)
html_output() {                                # [2005-05-24]
    local IMAGE=$1 THUMB=$2 X="" Y="" I        #   localise the variables
    local -a thumb                             #
    if [[ -f $THUMB ]]; then                   #   if thumbnail exists
        thumb=($(decode_image $THUMB|pnmfile)) #     get "pnmfile" info
        # pnmfile output looks like: "stdin:  PPM raw, 1024 by 768  maxval 255"
        # So we look for word "by" and then extract the 'words' before and
        # after that word.
        I=$thumb[(i)by]                        #     word number of word "by"
        if [[ $I -le $#thumb &&                #     if word "by" occured and
              $thumb[I-1] == [0-9]## &&        #       'words' before and after
              $thumb[I+1] == [0-9]## ]]; then  #       that both are numbers
            X=" width=\"$thumb[I-1]\""         #       set image width tag
            Y=" height=\"$thumb[I+1]\""        #       set image height tag
        fi                                     #
        # output html (thumb linked to large image)
        echo "<a href=\"$IMAGE\"><img src=\"$THUMB\"$X$Y /></a>"
    else                                       #
        # output html (filename linked to large image)
        echo "<a href=\"$IMAGE\">$THUMB</a>"   #
    fi                                         #
}                                              #


# Usage: decode FILE
# (Returns FILE in netpbm format on STDOUT.)
typeset -A decode_command                      # image decoder command cache
decode_image() {                               # [2005-05-24]
    local FILE=$argv[1] TYPE CMD               #   arg: file name
    TYPE=${(L)"$(file --brief --dereference \
        -- $FILE)"[(w)1]}                      #   1st word of "file" output
    CMD=$decode_command[$TYPE]                 #   get image command from cache
    if [[ -z $CMD ]]; then                     #   no command found in cache
        # use *topbm and *topgm as well?
        CMD="$(whence ${TYPE}top{n,p}m)"       #     get command(s) to use
        CMD=$CMD[(f)1]                         #     use 1st command if several
        if [[ -z $CMD ]]; then                 #     ERROR: unknown format
            error "Can't decode '$FILE': Unknown file format '$TYPE'" #'"
            return 1                           #
        fi                                     #
        decode_command[$TYPE]=$CMD             #     store command in cache
    fi                                         #       (for next use time)
    $CMD -- $FILE 2>/dev/null                  #   decode file
}                                              #


# Usage: read_rcfiles FILE
# (Reset the default options for FILE by [re-]reading relevant rcfiles.)
read_defaults() {                              # [2005-05-24]
    local -a rcfile                            #
    local FILE=$1 DIR                          #
    DIR="$(cd $FILE:h; echo $PWD)"             #   full path of argument file
    [[ $DIR == $OLDDIR ]] && return 0          #   don't reparse if same as
    OLDDIR=$DIR                                #     during previous call

    rcfile=()                                  #   array of rcfiles to read
    while true; do                             #
        [[ -e $DIR/$RCFILE ]] &&               #
            rcfile=($DIR/$RCFILE $rcfile)      #
        DIR=$DIR:h                             #
        [[ $DIR == / ]] && break               #
    done                                       #



    # bugs in zsh (ZSH_VERSION = 4.2.1)?
    #
    #   REM='\ #(|\#*)'
    #   [[ $XX == ${~REM} ]]
    #   Does not test for the pattern found in $REM. :(
    #
    #   X=",.,:"
    #   echo ${X//(#m),[.:]/»${MATCH#,}«}
    #
    #   Does not output the expected "».«»:«", but instead "».»:«:" (though
    #   using ${X/..} instead of ${X//..} returns the expected "».«,:").
    #   Obviously somethings off with the offset of the second match.
    #


    # FIXME: quote escape removal is non-trivial because of the above zsh bugs
    # (?) -- the problem could probably be solved using a loop and smart usage
    # of $x[$i,-1] in combination with $x[(i)PATTERN]. But I'm too lazy to
    # figure this out right now.

    foreach FILE ($rcfile); do                 # for each rc-file
        echo "$FILE"                           #   DEBUG output
        local ROW=0                            #   reset line counter
        while read -r XX; do                   #     read each line in file
            (( ROW ++ ))
            while [[ $XX == *\\\ # ]] &&       #       read \-continued rows
                    read -r YY; do             #
                XX=${XX%\\}$YY                 #         add continued line
                (( ROW ++ ))                   #         inc line counter
            done                               #
            [[ $XX == \ #(|\#*) ]] && continue #     skip blank lines
            echo -E "  $ROW: $XX"              #     x
            match=()
            if [[ $XX == \ #(#b)([a-z0-9_]##)\ #=\ #(*) ]]; then
                LHS=$match[1]
                RHS=$match[2]
                if   [[ $RHS == \'(#b)((#B)(\\\'|\\\\|?)##)\'\ #(|\#*) ]]; then
                    VALUE=${match[1]//(#m)'\'[\'\\]/<${MATCH}>}
                    echo "     single quoted string:"
                    echo -E "           key: $LHS"
                    echo -E "         value: $VALUE   ($match[1])"
                    echo -E "       comment: $match[2]"
                elif [[ $RHS == (#b)(\"(#B)(\\?|?)##\")\ #(|\#*) ]]; then
                    echo "     double quoted string:"
                    echo "       $LHS => $match[1]"
                    echo "       comment: $match[2]" 
                elif [[ $RHS == (#b)([a-z0-9_]##)\ #(|\#*) ]]; then
                    echo "     bareword string:"
                    echo "       $LHS => $match[1]"
                    echo "       comment: $match[2]"
                else
                    error "Syntax error in '$FILE' on line $ROW" #'"
                fi

            fi
        done < $FILE
    done
}



###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################


emulate -RL zsh                                # reset zsh options
setopt extended_glob                           #   extended globs, never error
EXE="${0##(${(j:|:)~path})/}"                  # remove path from $0

# parse command line args
files=()                                       # init file list
while ((ARGC > 0)) do                          # for each command line argument
    case $1 in                                 #
        (-f|--force)  FORCE=yes             ;; #   -f, --force
        (-h|--help)   help                  ;; #   -h, --help
        (--html)       HTML_OUTPUT_ONLY=''     #       --html
                       HTML_OUTPUT=yes         #
                       VERBOSE=''           ;; #
        (--html-only)  HTML_OUTPUT_ONLY=yes    #       --html-only
                       HTML_OUTPUT=''          #
                       VERBOSE=''           ;; #
        (-o*|--output(=*|))                    #   -o, --output=TYPE
            1=${1##(-o|--output(=|))}          #     strip option name
            [[ -z $1 ]] && shift               #     get option value
            FORMAT=${(L)1}                     #     (in lowercase)
          ;;                                   #
        (-p*|--prefix(=*|))                    #   -s, --prefix=WORD
            1=${1##(-s|--prefix(=|))}          #     strip option name
            [[ -z $1 ]] && shift               #     get option value
            PREFIX=$1                          #
          ;;                                   #
        (-q|--quiet)  QUIET=yes             ;; #   -q, --quiet
        (-s*|--suffix(=*|))                    #   -s, --suffix=WORD
            1=${1##(-s|--suffix(=|))}          #     strip option name
            [[ -z $1 ]] && shift               #     get option value
            SUFFIX=$1                          #
          ;;                                   #
        (-t|--types)   types                ;; #   -t, --types
        (-v|--verbose) HTML_OUTPUT_ONLY=''     #   -v, --verbose
                       HTML_OUTPUT=''          #
                       VERBOSE=yes          ;; #
        (-x*|--width(=*|))                     #   -x, --width=PIXELS
            1=${1##(-x|--width(=|))}           #     strip option name
            [[ -z $1 ]] && shift               #     get option value
            WIDTH=$1                           #
          ;;                                   #
        (-y*|--height(=*|))                    #   -y, --height=PIXELS
            1=${1##(-y|--height(=|))}          #     strip option name
            [[ -z $1 ]] && shift               #     get option value
            HEIGHT=$1                          #
          ;;                                   #
        (--) shift; break                   ;; #   --
        (-*) error "Unknown option '$1'"    ;; #   '"
        (*) files=($files $1)               ;; #   other args (i.e. filenames)
    esac                                       #
    shift                                      #   remove it from $argv
done                                           #
argv+=($files)                                 # append filenames to $argv
EXTENSION=${extension[$FORMAT]:-$FORMAT}       # choose output file extension
(( ERRORS > 0 )) && exit 10



###############################################################################
##                                                                           ##
##  Main Program                                                             ##
##                                                                           ##
###############################################################################


[[ $ARGC -eq 0 ]] &&                           # no command line args?
    error 'No files specified' 1               #   then stop totally
[[ -z $SUFFIX && -z $PREFIX ]] &&              #
    error "Can't overwrite files: You need to specify a suffix/prefix" 5 #'"
ENCODE="$(whence -p p{n,p}mto${FORMAT})"       # image encoder command
ENCODE=$ENCODE[(f)1]                           #   (use only 1st line)

[[ -z $ENCODE ]] &&                            # ERROR: no encoder found
    error "Can't output in '$FORMAT' format: No encoder program found" 5 #'"


# Weed out thumbnails from list of files to process.
# ('Cause who needs a thumbnail for a thumbnail?)
if [[ -z $FORCE ]]; then                       # --force wasn't used
    # Remove all suspected thumbnails from the list of files to thumbify. (A
    # file is suspected to be a thumbnail if it includes the thumbnail prefix
    # and suffix and if there exist an image which it could be the thumbnail
    # for.)
    local -a thumb                             #   list of thumbs
    thumb=()                                   #
    for (( I = 1; I <= ARGC; )); do            #   for each argument
        if [[ $argv[I] == $PREFIX(#b)(*)$SUFFIX.$EXTENSION ]]; then
            f=($match[1].[^.]##)               #     that may be a thumbnail
            if (( $#f > 0 )); then             #     and for which an image
                thumb+=$argv[I]                #       exists
                argv[I]=()                     #       remove from args
                continue                       #       and goto next arg
            fi                                 #
        fi                                     #
        (( I ++ ))                             #
    done                                       #
    if [[ -n $VERBOSE ]]; then                 #   on --verbose
        echo "Won't thumbify the following files:" #'"
        echo "(Because they look like thumbnails already.)"
        foreach THUMB ($thumb); do             #
            echo "    $THUMB"                  #
        done                                   #
    fi                                         #
fi                                             #


# FIXME: check age and weed don't update thumbnails which would become
# identical anyway

typeset -A def                                 # defaults read from rcfile(s)
foreach INFILE in $argv[@]; do                 # for each file

    # look for rc file to parse
    # (in current dir, and then stripping of one dir at a time until we reach /,
    # fallback on user's $HOME, and then /etc/thumbifyrc)
    #read_defaults $INFILE

    # FIXME: should read defaults to use (if not overriden by command line
    # options) here -- these defaults should be a composite of several
    # .thumbifyrc files [a la apache's .htaccess] -- last fallback/defaults
    # files should be ~/.thumbifyrc and /etc/thumbifyrc)


    [[ $INFILE == - ]] && INFILE=./-           #
    # output filename                          #
    OUTFILE=${INFILE:h}/$PREFIX${INFILE:t:r}$SUFFIX.$EXTENSION
    if [[ ! -e $INFILE ]]; then                #   ERROR: no such file
        error "Can't thumbify '$INFILE': File not found"
        continue                               #
    elif [[ ! -f $INFILE ]]; then              #   ERROR: not a proper file
        error "Can't thumbify '$INFILE': File is not a regular file"
        continue                               #
    elif [[ ! -r $INFILE ]]; then              #   ERROR: read protected
        error "Can't thumbify '$INFILE': File is read protected"
        continue                               #
    fi                                         #
    if [[ -n $VERBOSE ]]; then                 #   on --verbose
        echo "$INFILE -> $OUTFILE"             #
    fi                                         #
    if [[ -n $HTML_OUTPUT_ONLY ]]; then        #   on --html-only
        html_output $INFILE ${OUTFILE#./}      #
        continue                               #
    fi                                         #
    decode_image $INFILE |                     #   decode image
        pnmscale -xysize $WIDTH $HEIGHT 2>/dev/null | # scale it
        $ENCODE >$OUTFILE 2>/dev/null || {     #     and encode scaled image
            rm $OUTFILE                        #       (erase result on fail)
            continue                           #
        }                                      #
    if [[ -n $HTML_OUTPUT ]]; then             #   on --html
        html_output $INFILE ${OUTFILE#./}      #
    fi                                         #
done                                           #
(( ERRORS > 0 )) && exit 1                     # exit with errors
exit                                           # or exit okay


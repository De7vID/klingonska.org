#!/usr/bin/perl
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':locale';
use lib do {
    use Cwd "realpath";
    my $path = (__FILE__ =~ m#^(.*)/#) ? $1 : ".";
    realpath("$path/../perl");
};
use KA::Help;
use vars qw($NAME $VERSION $YEAR);
$VERSION = "0.2a";
$YEAR    = "2011-2013";
$NAME    = "check-dict";

# FIXME
#   o invoke 'check-dict --checksum' on git commit
#   o add check for unknown sections
#

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

sub TRUE  {  1 }
sub FALSE { "" }

my %opt = (
    verbose => 0,
);
my %cfg = (
    canon_path     => "../site/canon", # relative to executable's path
    field_order    => [ qw(tlh  warn pos  en   sv   desc def  ref
                           cite com  pun  see  tag  data id   meta) ],
    field_required => [ qw(tlh pos sv en def tag id) ],
    field_callbacks => {
        tlh  => \&check_tlh,
        warn => \&check_warn,
        pos  => \&check_pos,
        en   => \&check_en,
        sv   => \&check_sv,
        desc => \&check_desc,
        def  => \&check_defref,
        ref  => \&check_defref,
        cite => \&check_cite,
        com  => \&check_com,
        pun  => \&check_pun,
        see  => \&check_see,
        tag  => \&check_tag,
        data => \&check_data,
        id   => \&check_id,
        meta => \&check_meta,
    },
);

# absolutify path to canon files
$cfg{canon_path} = do {
    use Cwd "realpath";
    my $script = realpath($0);
    use File::Spec 'splitpath';     # dir part of scripts name
    my ($volume, $scriptdir) = File::Spec->splitpath($script);
    realpath($scriptdir . "/" . $cfg{canon_path});
};

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub help {
    KA::Help::usage(<<EOF);
Exit value 0 means that no problems were encountered, 1 that one or more checks
failed, 255 if there was some processing error (non-existing file, no input
etc).
EOF
}

sub list_eq(\@\@) {
    my ($a_ref, $b_ref) = @_;
    return "" if $#$a_ref != $#$b_ref;
    foreach (0..$#$a_ref) {
        if ($a_ref->[$_] ne $b_ref->[$_]) { return "" }
    }
    return 1;
}

sub get_metadata {
    my @dict = @_;
    my %metadata = ();
    my $field = "";
    foreach my $line (0..$#dict) {
        local $_ = $dict[$line];
        /^\s*$/ and last;                      # blank line = end of metadata
        /^\s+(.*)/ and do {                    # indented line
            die "Unexpected continuation line in metadata at line " .
                ($line + 1) . "\n"
                    unless $field;
            $metadata{$field} .= " $1";
            next;
        };
        /([^:\s]+):\s*(.*)/ and do {           # field: value line
            $field = $1;
            $metadata{$field} = $2;
            next;
        };
        die "Syntax error in metadata at line " . ($line + 1) . "\n";
    }
    return %metadata;
}

# Extracts a section from $listref, return line number of first line + list
# containing the section. $offset is added to the returned line number.
sub get_section {
    my ($indicator, $section, $listref) = @_;
    die "get_section(): last arg must be listref" if ref($listref) ne "ARRAY";
    my ($beg, $end) = (0, 0);
    START: {
        my $str = "$indicator start-of-$section $indicator";
        my $re  = qr/^$str$/;
        foreach (0 .. $#$listref) {            # find start of section
            if ($listref->[$_] =~ m#$re#) {
                $beg = $_;
                last START;
            }
        }
        warn "Failed to find start of section: '$str'\n";
        return ();
    }
    ENDING: {
        my $str = "$indicator end-of-$section $indicator";
        my $re  = qr/^$str$/;
        foreach ($beg .. $#$listref) {         # find end of section
            if ($listref->[$_] =~ m#$re#) {
                $end = $_;
                last ENDING;
            }
        }
        warn "Failed to find end of section: '$str'\n";
        return ();
    }
    return (
        [ @$listref[0        .. $beg       ] ],    # preamble
        [ @$listref[$beg + 1 .. $end - 1   ] ],    # data hunk
        [  $listref->[$end]                  ],    # end delimiter
        [ @$listref[$end + 1 .. $#$listref ] ],    # postamble
    );
}

sub sha1sum {
    my ($listref) = @_;
    use Digest::SHA "sha1_hex";
    return sha1_hex(Encode::encode("UTF-8", join("", @$listref)));
}

sub sortkey_tlh {
    local ($_) = @_;
    # %alph{klingon_letter} = sort_key
    my %alph = (
        a   => 'a',   b => 'b',   ch => 'c',   D => 'd',   e => 'e',
        gh  => 'f',   H => 'g',   I  => 'h',   j => 'i',   l => 'j',
        m   => 'k',   n => 'l',   ng => 'm',   o => 'n',   p => 'o',
        q   => 'p',   Q => 'q',   r  => 'r',   S => 's',   t => 't',
        tlh => 'u',   u => 'v',   v  => 'w',   w => 'x',   y => 'y',
        "'" => 'z',
    );
    s#[^a-zA-Z']##g;                           # strip non-alpha chars
    my $re1 = join("|", sort keys %alph);      # replace alpha w/ sort count
    s{($re1)(?=($re1)*$)}{ $alph{$1} }eg;
    return $_;
}

sub ordinal {
    local ($_) = @_;
    return $_ . "st" if m#1$#;
    return $_ . "nd" if m#2$#;
    return $_ . "rd" if m#3$#;
    return $_ . "th";
}

sub word_wrap {
    (local $_, my $width) = (@_, 80);
    s#[ \n]+# #g;
    s#(.{1,$width})(?:[ ]+|$)#$1\n#g;
    chomp;
    return $_;
}

sub prettify_entry {
    my ($entry, $order) = @_;
    my @x =  (join("", map {
        prettify_field($entry, $_)
    } @$order) . "\n");
    return @x;
}

sub prettify_field {
    my ($entry, $field) = @_;
    return map {
        my $x = word_wrap($_, 71);
        $x =~ s#^#\t#mg;
        "$field:$x\n";
    } @{ $entry->{$field} };
}


# Usage: @entry = get_entries(
#            data     => \@DATA,
#            offset   => $OFFSET,
#            order    => \@ORDER,
#            callback => \&CALLBACK
#        );
#
# @DATA should contain a section part the database file, each line in a
# separate element (as read by '<>' and extracted by get_section()).
#
# $OFFSET is the line number in the database file of the first line of text in
# @DATA.
#
# @ORDER is a list of field names, containing the names of all allowed fields
# in the order which they must occur within an entry. All allowed field names
# must be included in this list.
#
# &CALLBACK will be called for each each entry as they are processed. It will
# be passed a single entry as argument (see below). The callback should do
# sanity checks of the entry and, if any problems were found, return a list of
# warning messages to be displayed. In an empty list is returned, the entry
# will be considered a-ok.
#
# Return list of entries, containing one hashref for each dictionary entry.
# Hashref key/value pairs corresponds to fields in database. The values,
# however, are listrefs (Usually only containing a single element, but in the
# case of fields allowed to occur multiple times within an entry -- currently
# only the 'site' field -- each field occurance get its own element in the
# listref.)
#
# Each entry also get the special key '_LINE_' containing the line number of
# the start of the entry in the database file.
#
# Here's an example entry (strings slightly truncated):
#
#     $entry = {
#         _LINE_ => 9818,                   # start line in database file
#         tlh    => [ "{nab} [1]" ],
#         pos    => [ "verb" ],
#         sv     => [ "«planera»" ],
#         en     => [ "<plan>" ],
#         def    => [ "TKD" ],
#         ref    => [ "ST5; HQ8:4 pp.12, 13 ('Notes from Star..." ],
#         cite   => [
#             "{nImbuS wej maghoS, He yInab.} 'Plot course ...",
#             "{He pagh-pagh-vagh-jav-pagh-jav yInab} 'Plot...",
#         ],
#         tag    => [ "KLCP1" ],
#     };
#
sub get_entries {
    my %arg = @_;
    my $callback = $arg{callback} // die "get_entries(): No 'callback' specified";
    my $data     = $arg{data}     // die "get_entries(): No 'data' specified";
    my $offset   = $arg{offset}   // die "get_entries(): No 'offset' specified";
    my $order    = $arg{order}    // die "get_entries(): No 'order' specified";
    my $current  = "";  # name of currently processed field
    my $entry    = {};  # currently processed entry
    my $entries  = [];  # complete list of read entries (returned result)
    my %order    = map { $order->[$_] => $_ } 0 .. $#$order;
    warn "Missing blank line after '=== ... ===', at line ${\($offset + 1)}\n"
        if $data->[0] !~ m#^$#;
    $entry = { _LINE_ => $offset + 1 };  # initial value
  LINE: foreach my $i (1 .. $#$data) {
        local $_ = $data->[$i];
        m#^$# and do {                         # blank line
            if (not $current) {
                warn "Multiple blank lines, at line ${\($offset + $i)}\n";
            } else {
                if (my @warn = &{ $callback }($entry)) {
                    warn map { "$_ entry at line $entry->{_LINE_}\n" } @warn;
                } else {
                    push(@$entries, $entry);
                    while (my ($field, $values) = each %$entry) {
                        next if $field eq "_LINE_";
                        foreach my $value (@$values) {
                            my $wrapped = word_wrap($value, 71);
                            if ($value ne $wrapped) {
                                my ($old, $new) = ($value, $wrapped);
                                foreach ($old, $new) {
                                    s#^#        #gm;
                                    s# #\e[45m \e[m#g;
                                    s#$#\e[34m¶\e[m#gm;
                                }
                                warn "Incorrect wordwrapping line in '$field:' field at line " .
                                    "$entry->{_LINE_}\n" .
                                        "    Current value:\n$old\n" .
                                        "    Should be:\n$new\n";
                            }
                        }
                    }
                    print prettify_entry($entry, $order) if $opt{verbose};
                }
                $current = "";
            }
            $entry = { _LINE_ => $offset + $i + 1 };
            next LINE;
        };
        m#^([^:\h]+):\t(.*)# and do {          # field: value line
            my ($field, $value) = ($1, $2);
            if (not exists $order{$field}) {   #   unknown field
                warn "Unknown field '$field:' at line ${\($offset + $i)}\n";
                # non-fatal error, continue processing
            } elsif ($order{$field} < ($order{$current} // -1)) { # field order
                warn "Field '$field:' too late in entry sort order " .
                    "at line ${\($offset + $i)}\n";
                # non-fatal error, continue processing
            }
            warn "Leading space in '$field:' field at line ${\($offset + $i)}\n"
                if $value =~ s#^\h+##;
            push(@{ $entry->{$field} }, $value);
            $current = $field;
            next LINE;
        };
        m#^\t(.*)# and do {                    # indented line
            my $value = $1;
            if ($current) {
                warn "Leading space in '$current:' field at line ${\($offset + $i)}\n"
                    if $value =~ s#^\h+##;
                $entry->{$current}[-1] .= "\n$value";
            } else {
                warn "Unexpected indented line at line &{\($offset + $i)}\n";
            }
            next LINE;
        };
        m#^===\h.*\h===$# and do {             # section separator
            warn "Unexpected '=== ... ===' line at line ${\($offset + $i)}\n";
            next LINE;
        };
        die "Syntax error in ZDB file at line ${\($offset + $i)}\n";
    }
    warn "Missing blank line before '=== ... ===', at line ${\($offset + $#$data)}\n"
        if $data->[-1] !~ m#^$#;
    return $entries;
}

{
    # these source reference words are not in all capitals
    my %tr = (
        bop      => "BoP",       email  => "Email",  hallmark    => "Hallmark",
        haynes   => "Haynes",    holqed => "HolQeD", news        => "News",
        paqbatlh => "paq'batlh", praxis => "Praxis", qepa        => "qep'a'",
        qephoma  => "qepHom'a'", sarek  => "Sarek",  "ves-qonos" => "veS-QonoS",
        web      => "Web",
    );
    my $re = qr/${\( join("|", sort keys %tr) )}/;

    sub recase_source {
        local ($_) = @_;
        if (not s/\b($re)\b/$tr{$1}/) {
            return uc($_);
        }
        return $_;
    }
}

sub get_source_names {
    # filenames in 'canon/' starting with number and ending in '.txt'
    my @file = do {
        opendir(my $dh, $cfg{canon_path})
            or die "Failed open transcript dir '$cfg{canon_path}': $!";
        grep /^\d.*\.txt$/, readdir($dh);
    };

    # abbr contains source_abbrev => filename
    my %file = map {                           # for each transcript file
        my $file = $_;
        s/\.txt$//;                            #   strip '.txt'
        if (not /-(news|email|qep(hom)?a|web)$/){# if email, news, web then
            s/^(\d+-)+//;                      #     strip leading date
        }
        (recase_source($_) => $file);
    } @file;
    $file{TKDa} = $file{TKD};                  # add for TKDa
    return %file;
}

# split string on semicolon, returns list with result
# (semicolons inside parentheses are ignored when splitting)
sub split_sources {
    my ($str) = @_;
    return ("$str;" =~ /(.*?(?:\([^)]*\)[^;(]*)*);/g);
}

{
    my %file = get_source_names();             # cache filenames
    sub check_source {
        (my $entry, my $field, local $_) = @_;
        my @warn;
        my $i = 0;
        foreach (split_sources($_)) {
            if ($i > 0) {
                s/^\s//  or  push @warn, "Missing space after semicolon in";
                s/^\s+// and push @warn, "Too many spaces after semicolon in";
            }
            $i ++;
            my ($abbr, $rest) = /^(\S*)(.*)/;  # 1st word of source + rest
            if (not $file{$abbr}) {            # check primary source
                push @warn, 'Invalid source "' . $_ . '" in';
            }
            # check secondary references (given in parentheses)
            if (my ($secondary) = $rest =~ m# \( (.*) \) #x) {
                push @warn, map {
                    $_ . " '($secondary)' in"
                } check_source($entry, $field, $secondary);
            }
            # FIXME: check source page references etc. here
        }
        return @warn;
    }
}

{
    my %bracket = ( '[' => ']', '{' => '}', '(' => ')',
                    '“' => '”', '«' => '»', '<' => '>');
    my %singlet = ( '~' => '~', '"' => '"' );
    my $re = quotemeta join "", sort
        keys %singlet, keys %bracket, values %bracket;

    # Usage: check_brackets(STRING[, CALLBACK]);
    #
    # Checks that all brackets are balanced in STRING. Return list of warnings
    # not all opening brackets closed with the corresponding close bracket.
    # Return empty list if no warnings were found.
    #
    # If CALLBACK is specified that function is called for each substring of
    # text between the brackets. CALLBACK is passed the following arguments:
    #
    #     * Substring
    #
    #     * The expect stack (a list of the closing brackets that
    #       check_brackets() expect to see before the end of the string).
    #       CALLBACK is invoked before stack is updated, so if the stack is
    #       empty you're on the 'base' level (outside all bracket structures).
    #
    #     * The current bracket found ("" when at end of string)
    #
    # E.g. if you call check_brackets("a(b)c") CALLBACK will be invoked three
    # times, with arguments:
    #
    #     1st: "a", [],      "("   # found (, on base level '[]'
    #     2nd: "b", [ ")" ], ")"   # found ), when expecting a ')'
    #     3rd: "c", [],      ""    # found eof, when not expecting any more
    #
    sub check_brackets {
        my ($str, $callback) = @_;
        my ($last_pos, @expect, @warn) = (0);
        while ($str =~ /([$re])/g) {
            my $bracket = $1;
            if ($callback) {
                my $pre_string = substr($str, $last_pos, ($-[1] - $last_pos));
                $last_pos      = $+[1];
                $callback->($pre_string, \@expect, $bracket);
            }
            # expected closing bracket/singlet
            if (@expect and $expect[-1] eq $bracket) {
                pop @expect;
                next;
            }
            if ($bracket{$bracket}) {          # opening bracket
                push @expect, $bracket{$bracket};
                next;
            }
            if ($singlet{$bracket}) {          # opening singlet
                push @expect, $singlet{$bracket};
                next;
            }
            push @warn, "Unexpected '$bracket' in";
        }
        if ($callback) {
            my $pre_string = substr($str, $last_pos);
            $callback->($pre_string, \@expect, "")
        }
        push @warn, map { "Unterminated '$_' in" } @expect;
        return @warn;
    }
}

{
    my %lect = (
        "older or upper-class word" => "äldre ord eller överklassord",
        "archaic"                   => "arkaiskt",
        "slang"                     => "slang",
        "regional"                  => "regionalt",
        "regional, slang"           => "regionalt, slang",
    );
    # dialect (check that [regional/slang/etc.] are same in 'en:' & 'sv:')
    sub check_dialect {
        my ($lang) = @_;
        my @sv = $lang->{sv} =~ /\[ ([^]]*) \]/gx;
        my @en = $lang->{en} =~ /\[ ([^]]*) \]/gx;
        return () if @en == 0 && @sv == 0;     # no dialect info; skip check
        if (@sv > 1 or @en > 1) {
            return "Only one dialect description '" .
                join(" ", map "[$_]", (@en > 1 ? @en : @sv)) .
                    "' is allowed in 'sv:' and";
        }
        if (@en != @sv) {
            return "Both or none of fields must have dialect " .
                "description in 'en:' and";
        }
        my ($en, $sv) = ($en[0], $sv[0]);
        s/\s/ /g for $en, $sv;
        if (not exists $lect{$en}) {
            return "Unknown dialect description '[$en]' in";
        }
        if ($sv ne $lect{$en}) {
            return "Bad translation of dialect description ('en:[$en]' " .
                "vs 'sv:[$sv]') in 'sv:' and";
        }
        return ();
    }
}


###############################################################################
##                                                                           ##
##  Field Check Callbacks                                                    ##
##                                                                           ##
###############################################################################

# These checks are passed the one entry + name of a field to check. Values of
# fields are always a LISTREF (where multiple occurances of the field is
# allowed, e.g. for 'cite' this listref will contain multiple elements, but
# most commonly there will be just one element).
#
# Callback functions are expected to return a list of strings, each describing
# a problem (if found). Should return empty list if no problems were found.
#
# $field = "tlh" # i.e. field name
# $entry = {
#     KEY => [ qw/ VALUE... / ],  # one VALUE for each occurance of field
#     ...
# }
#
# Return list of error messages or empty list if ok.

sub check_tlh {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my $pos  = $entry->{pos}[0]  // "";        # part-of-speech
    my $data = $entry->{data}[0] // "";        # data field
    my @warn;

    # get/check word counters
    my ($pre, $word, $post) = m#^(.*?)(\*?\{[^{}]*\})(.*?)$#
        ? ($1, $2, $3) : ("", "", "");
    return "Mising Klingon word '{...}' in" unless $word;
    push @warn, "Not single space between '$pre' and '$word' in"
        if $pre and $pre =~ s#(\h*)$## and length($1) != 1;
    push @warn, "Not single space between '$word' and '$post' in"
        if $post and $post =~ s#^(\h*)## and length($1) != 1;

    if ($word =~ m#\h#) {
        push @warn, "Missing tag 'phrase' in 'data:' field when there are " .
            "several words {...} in" unless $data =~ m#\bphrase\b#m;
    }

    my $hyp = do {                            # pre-word counter
        if ($pre =~ m#^\[(\d+)\]$#) {
            $1 // 0;
        } else {
            push @warn, "Invalid pre-word data '$pre' for '$word' in" if $pre;
            0;
        }
    };
    my ($sub, $subsub) = do {                 # post-word counter and sub-counter
        if ($post =~ m#^\[(\d+)?(?:\.(\d+))?\]$#) {
            ($1 // 0, $2 // 0);
        } else {
            push @warn, "Invalid post-word data '$post' for '$word' in" if $post;
            (0, 0);
        }
    };

    state $prev_word   = "";
    state $prev_pos    = "";
    state $prev_hyp    = 0;
    state $prev_sub    = 0;
    state $prev_subsub = 0;
    if ($word eq $prev_word) {                 # change (= clear counters)
        push @warn, "Duplicate entry '$word' in"
            if $hyp == $prev_hyp and $sub == $prev_sub and $subsub == $prev_subsub;
        # check that counters did not disappear when they weren't supposed to
        push @warn, "Pre-word counter '[" . ($prev_hyp + 1) . "]' missing for '$word' in"
            if $hyp == 0 and $prev_hyp > 1;
        push @warn, "Post-word counter '[" . ($prev_sub + 1) . "]' missing for '$word' in"
            if $sub == 0 and $prev_sub > 0 and $hyp == $prev_hyp;
        push @warn, "Post-word sub-counter '[." . ($prev_subsub + 1) . "]' missing for '$word' in"
            if $subsub == 0 and $prev_subsub > 0 and $sub == $prev_sub and $hyp == $prev_hyp;
    } else {
        push @warn,  "Pre-word ". "counter for previous entry stopped at '[1]' in"
            if $prev_hyp    == 1;
        push @warn, "Post-word ". "counter for previous entry stopped at '[1]' in"
            if $prev_sub    == 1;
        push @warn, "Post-word sub-counter for previous entry stopped at '[.1]' in"
            if $prev_subsub == 1;
        ($prev_hyp, $prev_sub, $prev_subsub) = (0, 0, 0);
    }

    if ($hyp) {                                # pre-word counter
        if ($hyp != $prev_hyp + 1) {           #   bad: not +1 change in counter
            push @warn, "Pre-word counter '[$hyp]' for '$word' may only " .
                "increase by one in"
                    unless $hyp == $prev_hyp and ($sub or $subsub);
        } else {                               #   ok: +1 change, clear subcount
            if ($hyp == 1) {                   #     initialized (= set to one)
                push @warn, "pre-word counter '[$hyp]' for '$word' may only " .
                    "be set to one when word changes, in" if $word eq $prev_word;
            } else {                           #     incremented
                push @warn, "pre-word counter '[$hyp]' for '$word' may only " .
                    "increase when word remains same, in" if $word ne $prev_word;
            }
            push @warn, "post-word ". "counter for previous entry stopped " .
                "at '[1]' in" if $prev_sub    == 1;
            push @warn, "post-word sub-counter for previous entry stopped " .
                "at '[.1]' in" if $prev_subsub == 1;
            ($prev_sub, $prev_subsub) = (0, 0);
        }
    }
    if ($sub) {                                # post-word counter
        if ($sub != $prev_sub + 1) {           #   bad: not +1 change in counter
            push @warn, "Post-word counter '[$sub]' for '$word' may only " .
                "increase by one in"           #     no change: will subcount change?
                    unless $sub == $prev_sub and $subsub;
        } else {                               #   ok: +1 change, clear subcount
            if ($sub == 1) {                   #     initialized (= set to one)
                push @warn, "Post-word counter '[$sub]' for '$word' may only " .
                    "be set to one when word or higher counter change in"
                        if $word eq $prev_word && $hyp == $prev_hyp;
            } else {                           #     incremented
                push @warn, "Post-word counter '[$sub]' for '$word' may only " .
                    "increase when part-of-speech change in"
                        if $pos eq $prev_pos;
            }
            push @warn, "Post-word sub-counter for previous entry stopped " .
                "at '[.1]' in" if $prev_subsub == 1;
            $prev_subsub = 0;
        }
    }
    if ($subsub) {                             # post-word sub-counter
        if ($subsub != $prev_subsub + 1) {     #   bad: not +1 change in counter
            push @warn, "Post-word sub-counter '[.$subsub]' " .
                "for '$word' may only increase by one in";
        } else {                               #   ok: +1 change, clear subcount
            if ($subsub == 1) {                #     initialized (= set to one)
                push @warn, "Post-word sub-counter '[.$subsub]' for '$word' " .
                    "may only be set to one when word or higher counter change in"
                        if $word eq $prev_word && $hyp == $prev_hyp && $sub == $prev_sub;
            } else {                           #     incremented
                push @warn, "Post-word sub-counter '[.$subsub]' for '$word' " .
                    "may only increase when part-of-speech remains same in"
                        if $pos ne $prev_pos;
            }
        }
    }
    ($prev_word, $prev_pos, $prev_hyp, $prev_sub, $prev_subsub) = ($word, $pos, $hyp, $sub, $subsub);

    # check klingon spelling
    state $re = qr/ (?:[bDHjlmnpqQrStvwy']|ch|gh|ng|tlh)(?:
            [aeI] (?:[bDHjlmnpqQrStv']|ch|gh|ng|tlh|[wy]'?|rgh)? |
            [ou]  (?:[bDHjlmnpqQrStv']|ch|gh|ng|tlh|  y '?|rgh)?    # "ow" and "uw" is not allowed
    )/x;
    if (not $word =~ m#^\*?\{(?:$re+(?:\s$re+|\s«$re+»)*|$re?-|-$re)\}$#o) {
        # non-phonotactic word
        push @warn, "Invalid syllable structure for '$word' in"
            if $data !~ m#\bnon-phonotactic\b#;
    } else {
        push @warn, "Incorrectly tagged 'non-phonotactic' in 'data:' " .
            "field, word '$word' is good in"
                if $data =~ m#\bnon-phonotactic\b#;
    }
    if (m#^\*#) {
        push @warn, "Missing 'warn:' field when there is a leading asterisk in"
            unless $entry->{warn};
        push @warn, "Missing 'see:' field when there is a leading asterisk in"
            unless $entry->{see};
        push @warn, "Missing 'deprecated' or 'non-canon' in 'data:' field " .
            "when there is a leading asterisk in"
            if $data !~ m#\b(?:deprecated|non-canon)\b#m;
    }
    return @warn;
}

sub check_warn {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    push @warn, check_brackets($_);
    my $tlh  = $entry->{tlh}[0]  // "";
    my $data = $entry->{data}[0] // "";
    push @warn, "First letter not lower case in" if m#^[A-Z]# and !/^I\b/;
    push @warn, "Last character is punctuation in" if m#[-.,:;([{<«  ]$#;
    push @warn, "Missing leading asterisk in 'tlh:' field when there is a"
        unless $tlh =~ m#^[*]#;
    if (/\bnon-canon\b/) {
        push @warn, "Missing 'non-canon' in 'data:' field when " .
            "'non-canon' is given in" if $data !~ m#\bnon-canon\b#m;
    } elsif (/\bcanon\b/) {
        push @warn, "Missing 'deprecated' in 'data:' field when " .
            "'canon' is given in" if $data !~ m#\bdeprecated\b#m;
    } else {
        push @warn, "Missing word 'canon' or 'non-canon' in";
    }
    return @warn;
}

sub check_pos {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    state $re = qr{^(?:
        verb(?:\s(?:prefix|suffix\stype\s(?:[1-9]|rover)))?|
        noun(?:\ssuffix\stype\s[1-5])?|
        name|adverbial|conjunction|exclamation|numeral|pronoun|question\sword
    )$}x;
    my @warn;
    push @warn, "Invalid part-of-speech '$_' in" unless m#$re#o;
    return @warn;
}

sub check_en {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    push @warn, check_brackets($_);

    # <...> or «...» are required (except for affixes)
    my $pos = $entry->{pos}[0] // "";          # part-of-speech
    push @warn, "Missing «...» or <...> brackets in"
        if $pos !~ m#\b(suf|pre)fix\b#m and !/[<«]/;

    # may not end in punctuation (question mark is okay)
    push @warn, "Last character is punctuation in" if m#[-!.,:;([{<«  ]$#;
    if (m#\((v|n|name|adv|conj|excl|num|pro|ques|ns[1-5]|vp|vs[1-9r])\)#) {
        push @warn, "Part-of-speech '($1)' must not be given in";
    }

    push @warn, check_dialect({
        en => $_,
        sv => $entry->{sv}[0],
    });
    return @warn;
}

sub check_sv {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    push @warn, check_brackets($_);

    # «...» are required (except for affixes), <...> may not occur
    my $pos = $entry->{pos}[0] // "";          # part-of-speech
    push @warn, "Missing «...» brackets in"
        if $pos !~ m#\b(suf|pre)fix\b#m and !/«/;
    push @warn, "<...> brackets are not allowed in" if m#[<>]#;

    # may not end in punctuation (question mark is okay)
    push @warn, "Last character is punctuation in" if m#[-!.,:;([{<«  ]$#;
    if (m#\((v|s|namn|adv|konj|interj|räkn|pro|fråg|ss[1-5]|vp|vs[1-9]s)\)# or
            m#\((v|n|name|adv|conj|excl|num|pro|ques|ns[1-5]|vp|vs[1-9r])\)#) {
        push @warn, "Part-of-speech '($1)' must not be given in";
    }

    return @warn;
}

# Callback function for check_brackets(). Verifies that all square brackets are
# correct source references, except if they're inside other brackets (in which
# case they are checked to NOT be valid source references).
sub check_desc_refs {
    my ($entry, $field, $str, $stack_ref) = @_;
    my @warn;
    if (@$stack_ref and $stack_ref->[-1] eq "]") {
        (my $src = $str) =~ s/\n/ /g;
        my @source_warn = check_source($entry, $field, $src);
        if (@$stack_ref == 1) {                # outmost level
            push @warn, @source_warn;          #   MUST be source ref
        } else {                               # inside other bracket
            if (@source_warn == 0) {           #   must NOT be source ref
                push @warn, "Square bracket '[$str]' inside other bracket may "
                    . "not contain source ref in"
            }
        }
    }
    return @warn;
}

sub check_desc {
    # Contents
    #   * Any number source references [...]
    #   * Any number of italics markers ~...~
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    push @warn, check_brackets($_, sub {
        push @warn, check_desc_refs($entry, $field, @_);
    });
    push @warn, "First letter not lower case in" if m#^[A-Z]# and !/^I\b/;
    while (m#~([^~]+)~#g) {                    # check ~...~ phrases
        local $_ = $1;
        push @warn, "First letter in '~$_~' is not lower case in"
            if m#^[A-Z]# and !/^(I|Vulcan|French)\b/;
        push @warn, "Last character in '~$_~' is punctuation in"
            if m#[-.,:;([{<«  ]$# and not m#\b(?:subj|obj)\.$#;
    }
    # punctuation not allowed at end, except as part of abbrev
    push @warn, "Last character is punctuation in"
        if m#[-.,:;([{<«  ]$# and !/(?:subj|obj)\.$/;
    push @warn, "Word '$1' should be abbreviated in"
        if m#\b(some(bod(y|ies)|ones?|things?))\b#;
    return @warn;
}

sub check_defref {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    s/\n/ /g;
    return check_source($entry, $field, $_)
}

sub check_cite {
    my ($entry, $field) = @_;
    my $i = 1;
    my @warn;
    foreach (@{ $entry->{$field} }) {          # for each 'cite:' field
        local $_ = $_;
        s/\n/ /g;
        if (s{ \s* \[( (?:[^]"]+|"[^"]*")* )\] $}{}x) { # check (required) sources
            my @source_warn = check_source($entry, $field, $1);
            if (@source_warn) {
                push @warn, map { "$_ " . ordinal($i) } @source_warn;
            }
        } else {
            push @warn, "Missing source in " . ordinal($i);
        }
        push @warn, map { "$_ " . ordinal($i) } check_brackets($_);
        $i += 1;
    }
    return @warn;
}

sub check_pun {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    push @warn, check_brackets($_);
    push @warn, "Last character is mid-sentence punctuation in"
        if m#[-,:;([{<«  ]$#;
    return @warn;
}

sub check_com {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    if (s{ \s* \[( (?:[^]"]+|"[^"]*")* )\] $}{}x) { # check (optional) sources
        local $_ = $1;
        s/\n/ /g;
        push @warn, check_source($entry, $field, $_);
    }
    push @warn, check_brackets($_);
    push @warn, "Last character is mid-sentence punctuation in"
        if m#[-,:;([{<«  ]$#;
    return @warn;
}

sub check_see {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    push @warn, check_brackets($_);
    # FIXME what if 'tlh:' field isn't defined here (?)
    my ($tlh) = $entry->{tlh}[0] =~ m#(\{.*?\})#;
    push @warn, "See also '$tlh' points to itself in"
        if defined($tlh) and m#$tlh#;
    return @warn;
}

{
    my %allowed_tag = map {
        (local $_ = $_) =~ s/_/ /g;
        $_ => 1;
    } qw(Anglicism animal architecture body_part clothing color country curse
         economics family fighting food KLCP1 Klingonism landscape math measure
         music placement quantity religion shape time weather);
    my %year = do {                            # source transcript years
        my %file = get_source_names();         #   transcript filenames
        $file{TKD} = "1985";                   #   override TKD year
        map {                                  #   make list of years
            $file{$_} =~ /^\d{4}/              #     file prefix: 4 digit year
                ? ($_ => $&)                   #       (skip files which do
                : ();                          #       not have year prefix)
        } keys %file;
    };
    sub check_tag {
        (my $entry, my $field, local $_) = @_;
        return "Duplicate" if @{ $entry->{$field} } > 1;
        my (@tag, @warn) = split /;\s/;

        # FIXME: should references from other fields also be considered?
        # (e.g. cite:, com: and desc:, maybe more?)
        if ($entry->{def} or $entry->{ref}) {
            my ($year, $src) = do {                # creation year, based on source
                local $_ = join("; ",              #   combine 'def:' and 'ref:'
                    $entry->{def}[0] // (),
                    $entry->{ref}[0] // (),
                );
                my %year = map {                   #   source years => source
                    exists $year{$_}               #     year for each word in $_
                        ? ($year{$_} => $_) : ();
                } (/(?:^|[;(])\s*([\w'-]+)/g);     #     after start '(', ';'
                my $first = (sort keys %year)[0];
                defined($first)
                    ? ($first, $year{$first})     #   oldest year + source
                    : (undef, undef);
            };
            push @warn, "First tag should be '$year' (not '$tag[0]') based on source " .
                "\"$src\" in" if defined($year) and $year ne $tag[0];
        }

        foreach (@tag[1..$#tag]) {
            push @warn, "Unknown tag '$_' in"
                unless exists $allowed_tag{$_};
        }
        my @sorted = sort { lc($a) cmp lc($b) } @tag;
        push @warn, "Tags must be sorted in" unless list_eq(@sorted, @tag);
        return @warn;
    }
}

sub check_data {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    push @warn, check_brackets($_);
    my $tlh = $entry->{tlh}[0] // "";
    if (/\b(deprecated|non-canon)\b/) {
        push @warn, "Missing leading asterisk in 'tlh:' field as '$1' is given in"
            unless $tlh =~ m#^[*]#;
    }
    if (/\b(phrase)\b/) {
        push @warn, "Missing space in 'tlh:' field as '$1' is given in"
            unless $tlh =~ m#^[^{]* {[^{]*[ ] [^{]*} #x;
    }
    return @warn;
}

{
    # character class matching base58
    my $char_class = join "", grep(!/[0OIl]/, "a".."z", "A".."Z", "0".."9");
    my $content_ok_re = qr/^[$char_class]{3}$/;
    # check that ID doesn't look too much like a Klingon word
    my $tlh_re = qr/^([bDHj1mnpqQrStvwy]|ch|gh|ng|t1h)[ouae1]?[bDHj1mnpqQrStvwy]?$/x;
    my %id_found = ();
    sub check_id {
        (my $entry, my $field, local $_) = @_;
        return "Duplicate" if @{ $entry->{$field} } > 1;
        return "Not three base58 characters in in" if not /$content_ok_re/;
        return "Value '$_' is too similar to Klingon word in" if /$tlh_re/;
        return "Value '$_' already exist in" if $id_found{$_};
        $id_found{$_} = TRUE;
        return ();
    }
}

sub check_meta {
    (my $entry, my $field, local $_) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my @warn;
    push @warn, check_brackets($_);
    push @warn, "First letter not upper case in"
        unless m#^\*?\{#x or (m#(\w)# and $1 eq uc($1));
    push @warn, "Last character is mid-sentence punctuation in" if m#[-,:;([{<«  ]$#;
    return @warn;
}

# Usage: check_entry(\@REQUIRED, \%CALLBACKS, \%ENTRY);
#
# Checks that all required fields are present, and invoke callbacks to check
# field values.
#
# Return list of warnings or empty list if entry was a-ok.
#
# @REQUIRED is list of fields which *must* be present in an entry (in no
# particular order).
#
# %CALLBACKS is a hash with check callbacks to invoke for each field. (No
# checks will be performed on fields for which there is no check function.)
#
# Keys are field names, and values are coderefs to invoke. Each callback is
# called as FUNCTION(\%ENTRY, $FIELD). Callback should return a list of
# warnings or empty list if checked field was a-ok.
#
# %ENTRY is a single dictionary entry. A hashref with listrefs as values.
# Multiple elements for the listrefs only occur for fields that occur multiple
# times within the same entry (e.g. 'cite').
sub check_entry {
    my ($required, $field_callbacks, $entry) = @_;
    my @warn = ();
    # check that required fields exists
    foreach (@$required) {
        push(@warn, "Missing required '$_:' field in")
            unless exists($entry->{$_});
    }
    # invoke callbacks for each field
    foreach (keys %$entry) {
        next unless exists $field_callbacks->{$_};
        my $field = $_;
        push @warn, map {
            "$_ '$field:' field in";
        } &{ $field_callbacks->{$_} }($entry, $_, $entry->{$_}[0]);
    }
    return @warn;
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

use Getopt::Long qw(
    :config posix_default bundling gnu_compat no_ignore_case permute
);
GetOptions(                             # info displayed by help()
    'checksum|c' => \$opt{checksum},    ### only check SHA1 sum in metadata
    'help|h'     => \&help,             ### display this help and exit
    'manpage|M'  => \&KA::Help::manpage,### display program manpage and exit
    'quiet|q'    => \$opt{quiet},       ### suppress word count summary at end
    'verbose|v'  => \$opt{verbose},     ### output normalized dict
    'version|V'  => \&KA::Help::version,### output version information and exit
) or exit 255;

die "$NAME: Missing input: Nothing on standard input, and no file specified\n" .
    "Use '$NAME --help' for more information.\n"
    if -t STDIN and @ARGV == 0;

###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

my $warnings = 0;                              # count warnings
local $SIG{__WARN__} = sub { $warnings ++; warn @_ };

my @whole_file = <>;  # read dictionary
my ($preamble, $datachunk, $enddelim, $postamble) =
    get_section("==", "data", \@whole_file) or exit 255;

# check metadata header
my %meta = get_metadata(@whole_file);
{                                              # check metadata 'SHA1'
    my $sha1 = sha1sum($datachunk);
    if ($sha1 ne $meta{SHA1}) {
        warn "Invalid 'SHA1' metadata (should be '$sha1')\n";
    }
    exit !!$warnings if $opt{checksum};        # abort on --checksum
    if ($opt{verbose} and $sha1 ne $meta{SHA1}) {
        foreach (@$preamble) {
            last if m#^$#;
            last if s#^(SHA1:\s*).*$#$1$sha1#;
        }
    }
}

# check line length and linefeed at end of file
# FIXME: should also check for PC line endings, and non-UTF8 (?)
foreach my $line (0..$#whole_file) {
    local $_ = $whole_file[$line];
    s{\t}{ " " x (8 - (pos() % 8)) }ge;  # replace tabs with spaces
    if (length($_) > 80) { # 80 = is with trailing newline
        warn "Line may not exceed 79 characters in line " . ($line + 1) . "\n";
    }
    if (/\h+$/) {
        warn "Trailing space at line " . ($line + 1) . "\n";
    }
}
if ($whole_file[-1] !~ m#\n$#) {
    warn "Missing linefeed at end of file at line " . ($#whole_file + 1) . "\n";
}

print @$preamble if $opt{verbose};


my ($prefix_count, $suffix_count, $word_count, $marked_count) = (0, 0, 0, 0);
my $offset = @$preamble + 1;
foreach my $section (qw/word verb-prefix verb-suffix noun-suffix/) {

    my ($preamble2, $datachunk2, $enddelim, $remaining) =
        get_section("===", "$section-list", $datachunk) or do {
        $warnings ++;
        next;
    };
    $datachunk = $remaining;                   # remaining in text datachunk

    print @$preamble2, "\n" if $opt{verbose};
    $offset   += @$preamble2;                  # adjust offset
    my $entries = get_entries(
        data     => $datachunk2,
        offset   => $offset,
        order    => $cfg{field_order},
        callback => sub {
            check_entry($cfg{field_required}, $cfg{field_callbacks}, @_);
        },
    );
    $offset += @$datachunk2 + @$enddelim;
    print @$enddelim if $opt{verbose};

    # check sort order in dictionary
    my ($last_sortkey, $last_word) = ("", "");
    foreach my $entry (@$entries) {
        $_ = $entry->{tlh}[0] // "";
        my ($marked, $word) = m#^.*? (\*?) \{([^}]*)\} .*? $#xm;
        $marked_count ++ if $marked;
        for ($word) {
            m#-$# and do { $prefix_count ++; next };
            m#^-# and do { $suffix_count ++; next };
            $word_count ++ unless $marked;
        }
        my $sortkey = sortkey_tlh($word);
        my $order   = ($last_sortkey cmp $sortkey);
        if ($order == 1) {
            warn "Wrong sort order: {$last_word} comes before {$word}, " .
                "in entry at line " . ($entry->{_LINE_}) . "\n";
        }
        $last_sortkey = $sortkey;
        $last_word    = $word;
    }
}

print @$enddelim, @$postamble if $opt{verbose};
warn "Last line must be '[[eof]]' at line " . scalar(@whole_file) . "\n"
    unless $whole_file[-1] =~ m#^\[\[eof\]\]$#;

print STDERR
    "Word count: $word_count (" .
    "prefixes: $prefix_count, " .
    "suffixes: $suffix_count, " .
    "*deprecated: $marked_count)\n"
    unless $opt{quiet};

if ($warnings) {
    print STDERR "$warnings problem(s) found\n";
    exit 1;
}
exit 0;

__END__

=head1 NAME

check-dict - check consistency of Klingonska Akademien's Klingon database file


=head1 SYNOPSIS

B<check-dict> [I<OPTION>]... [I<FILE>]


=head1 DESCRIPTION

This tool is used to check the integrity of Klingonska Akademien's I<Online
Klingon Pocket Dictionary> database <http://klingonska.org/dict/>, and report
any problems and inconsistencies within it.

The database is in ZDB (Zrajm DataBase) format, a very simple text format,
intended to be human readable, as well as machine parsable. The database is
available online for browsing or fetching for anyone who wishes to do so. It
also contains a metadata header intended to simplify syncing against the
dictionary for external apps and programs.


=head1 OPTIONS

Mandatory arguments to long options are mandatory for short options too.


=over 8

=item B<-c>, B<--checksum>

Fast way to only check the 'SHA1' checksum of the metadata (all other checks as
are skipped). This option is primarily intended for use in publish and commit
hooks (where speed is of the essence).

It is vitally important that the 'SHA1' metadata field correctly reflects the
database content at all times, since this is used by external apps and programs
that wishes to sync against the dictionary. Implies B<--quiet>.


=item B<-h>, B<--help>

Output brief command line help on standard output, then exit.


=item B<-M>, B<--manpage>

Display program manpage and exit. This option extracts the Perl POD (Plain Old
Documentation) documentation from the program and displays it using man(1).


=item B<-q>, B<--quiet>

Suppress the word count summary at the end of processing.


=item B<-v>, B<--verbose>

Output a re-word-wrapped dictionary on standard output during processing.

When B<check-dict> terminates with a zero exit status, output should be
identical to input, otherwise minor corrections (e.g. word wrap and field
order) will be corrected in the output. (NOTE, however, that some errors can
only be fixed manually. When in doubt, you can run B<check-dict> again on the
outputted file to see if any errors remain.)


=item B<-V>, B<--version>

Output version information on standard output, then exit.

=back


=head1 EXIT STATUS

Exit status will be 0 if all checks were passed, 1 if one or more checks failed
and 255 if B<check-dict> died for some other reason (unknown options, missing
input, whatever).


=head1 EXAMPLES

Here are a couple of examples. After each example comes an explanation of what
it does.

    bin/check-dict <site/dict/dict.zdb

This is how one would typically invoke B<check-dict>. It runs all checks and
does all the stuff one expects.

    bin/check-dict --checksum <site/dict/dict.zdb

This forgoes most of the checks, loads the dictionary and only checks the
'SHA1' checksum of the metadata. It is primary intended for use in publish and
commit hooks (as it is vitally important that this value never is incorrect for
syncing to work well for external programs/apps).

    bin/check-dict site/dict/dict.zdb | diff site/dict/dict.zdb -

Compare difference in word wrapping between the existing dictionary file, and
an "ideal" version of it. (When standard output is redirected somewhere
B<check-dict> will act as if given the B<--verbose> option -- thereby
outputting a normalized version of the database -- here we simply feed that to
diff(1) to see if B<check-dict> performed any changes.


=head1 AUTHOR

Written by zrajm <zrajm@klingonska.org>, 2011-2013.


=head1 COPYRIGHT AND LICENSE

Copyright 2011-2013 zrajm <zrajm@klingonska.org>.

Distributed under Creative Commons Attribution-ShareAlike 3.0 Unported (CC
BY-SA 3.0) http://creativecommons.org/licenses/by-sa/3.0/

This means that you may copy, sell and change the program in any way you like,
as long as you still attribute it to this author, and release your modified
version under the same license.


=head1 SEE ALSO

Take a look at the database file itself for a description of its format
http://klingonska.org/dict/dict.zdb.

For a web interface to the dictionary, see Klingonska Akademien's I<Online
Klingon Pocket Dictionary> (at http://klingonska.org/dict/), and for other
stuff about the Klingon language, see Klingonska Akademien's web site in
general http://klingonska.org/.

=cut

#[eof]

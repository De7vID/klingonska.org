#!/usr/bin/perl
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':locale';

# FIXME
#   o invoke 'check-dict --checksum' on git commit
#   o add check for unknown sections
#

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

use vars qw($NAME $VERSION $YEAR);
$VERSION = "0.2a";
$YEAR    = "2012";
$NAME    = "check-dict";

sub TRUE  {  1 }
sub FALSE { "" }

my %opt = ();
my %cfg = (
    canon_path     => "../site/canon", # relative to executable's path
    field_order    => [ qw(tlh  warn  pos  sv   en    desc  def   ref  cite
                           com  pun   see  tag  data  id    file  meta) ],
    field_required => [ qw(tlh pos sv en def id file) ],
    field_callbacks => {
        tlh  => \&check_tlh,
        warn => \&check_warn,
        pos  => \&check_pos,
        en   => \&check_en,
        sv   => \&check_sv,
        desc => \&check_desc,
        def  => \&check_source,
        ref  => \&check_source,
        cite => \&check_cite,
        com  => \&check_com,
        pun  => \&check_pun,
        see  => \&check_see,
        tag  => \&check_tag,
        data => \&check_data,
        id   => \&check_id,
        file => \&check_file,
        meta => \&check_meta,
    },
);

# absolutify path to canon files
$cfg{canon_path} = do {
    use Cwd 'realpath';             # scripts absolute name
    my $script = realpath($0);
    use File::Spec 'splitpath';     # dir part of scripts name
    my ($volume, $scriptdir) = File::Spec->splitpath($script);
    realpath($scriptdir . "/" . $cfg{canon_path});
};


###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub read_file {
    my ($file) = @_;
    open(my $in, "<:utf8", $file)
        or die "Failed to open file '$file' for reading\n";
    return wantarray ? <$in> : join("", <$in>);
}

# Convert POD into ANSI escape sequences for the terminal. Does not do
# recursion. (But since E<...> is handled first, those are allowed inside both
# B<...> and I<...>, and since C<...> is treated last, all other POD sequences
# are allowed inside those.)
sub pod2ansi {
    my ($_) = @_;
    return undef unless defined($_);
    my %char = (quot => '"', amp => '&', lt => '<', gt => '>');
    s#E<([^>]*)>#$char{lc $1}#g;     # HTML-like entity
    s#B<([^>]*)>#\e[1m$1\e[0m#g;     # bold
    s#[FI]<([^>]*)>#\e[4m$1\e[0m#g;  # italic / filename
    s#C<([^>]*)>#"$1"#g;             # quoted code
    return $_;
}

sub version {
    print "$NAME (klingonska.org) $VERSION\n",
        "Copyright (C) $YEAR Zrajm C Akfohg <zrajm\@klingonska.org>\n",
        "License CC BY-SA 3.0: Creative Commons Attribution-ShareAlike 3.0 Unported\n",
        "    <http://creativecommons.org/licenses/by-sa/3.0/>\n";
    exit 0;
}

sub manpage {
    use Cwd 'realpath';
    exec 'pod2man "' . realpath($0) . '"|man -l -'
        or die "Failed to exec 'pod2man'"
}

sub help {
    use Cwd 'realpath';
    my $_ = read_file(realpath($0));
    my ($synopsis)    = m#^=head1 \s+ SYNOPSIS \s+ (.*)#mx;
    my ($description) = m#^=head1 \s+ NAME \s+ [-\w]+ \s+-\s+ (.*)#mx;
    print "Usage: " . pod2ansi($synopsis) . "\n",
        ucfirst($description) . ".\n";
    { # list --options (from comments) -- sort by longopt name
        my @opt_doc = ();
        my $opt_length = 0;
        while (/^ \s*
                (?: (['"])                  # start quote
                    ([^\n'"=:|]*?)           #   long opt
                    (?:\|([^\n'"=:]*))?      #   short opt
                    (?:([:=])[^\n'"=]*)?    #   opt arg
                    \1 [^#]*                # end quote
                |.*?)?(?<!\#)\#\#\#\s+(.*)$/xmg) { # description
            my $long  = $2 ? "--$2"  : "";
            my $short = $3 ?  "-$3," : "";
            my $arg   = $4;
            my $desc  = $5;
            if ($arg and $desc =~ s/([A-Z0-9]+)\s*//) {
                $long .= $arg eq ":" ? "[=$1]" : "=$1";
            }
            push(@opt_doc, [ $short, $long, pod2ansi($desc) ]);
            my $length = length($long);
            $opt_length = $length if $length > $opt_length;
        }
        # length of longest option name
        if (@opt_doc) {
            print "\nOptions:\n", map {
                sprintf "  %-3s %-${opt_length}s  %s\n", @$_
            } @opt_doc;
        }
    }
    print <<EOF;

Exit value 0 means that no problems were encountered, 1 that one or more checks
fail, 255 if there was some processing error (non-existing file, no input etc).
EOF
    exit 0;
}

sub get_metadata {
    my @dict = @_;
    my %metadata = ();
    my $field = "";
    foreach my $line (0..$#dict) {
        given ($dict[$line]) {
            when (/^\s*$/) { last }            # blank line = end of metadata
            when (/^\s+(.*)/) {                # indented line
                die "Unexpected continuation line in metadata at line " .
                    ($line + 1) . "\n"
                        unless $field;
                $metadata{$field} .= " $1";
            }
            when (/([^:\s]+):\s*(.*)/) {       # field: value line
                $field = $1;
                $metadata{$field} = $2;
            }
            default {
                die "Syntax error in metadata at line " . ($line + 1) . "\n";
            }
        }
    }
    return %metadata;
}

# Extracts a section from $listref, return line number of first line + list
# containing the section. $offset is added to the returned line number.
sub get_section {
    my ($indicator, $section, $listref) = @_;
    die "get_section(): last arg must be listref" if ref($listref) ne "ARRAY";
    my ($beg, $end) = (0, 0);
    START: {
        my $str = "$indicator start-of-$section $indicator";
        my $re  = qr/^$str$/;
        foreach (0 .. $#$listref) {            # find start of section
            if ($listref->[$_] =~ m#$re#) {
                $beg = $_;
                last START;
            }
        }
        warn "Failed to find start of section: '$str'\n";
        return ();
    }
    ENDING: {
        my $str = "$indicator end-of-$section $indicator";
        my $re  = qr/^$str$/;
        foreach ($beg .. $#$listref) {         # find end of section
            if ($listref->[$_] =~ m#$re#) {
                $end = $_;
                last ENDING;
            }
        }
        warn "Failed to find end of section: '$str'\n";
        return ();
    }
    return (
        [ @$listref[0        .. $beg       ] ],    # preamble
        [ @$listref[$beg + 1 .. $end - 1   ] ],    # data hunk
        [  $listref->[$end]                  ],    # end delimiter
        [ @$listref[$end + 1 .. $#$listref ] ],    # postamble
    );
}

sub sha1sum {
    my ($listref) = @_;
    use Digest::SHA "sha1_hex";
    return sha1_hex(Encode::encode("UTF-8", join("", @$listref)));
}

sub sortkey_tlh {
    my ($_) = @_;
    # %alph{klingon_letter} = sort_key
    my %alph = (
        a   => 'a',   b => 'b',   ch => 'c',   D => 'd',   e => 'e',
        gh  => 'f',   H => 'g',   I  => 'h',   j => 'i',   l => 'j',
        m   => 'k',   n => 'l',   ng => 'm',   o => 'n',   p => 'o',
        q   => 'p',   Q => 'q',   r  => 'r',   S => 's',   t => 't',
        tlh => 'u',   u => 'v',   v  => 'w',   w => 'x',   y => 'y',
        "'" => 'z',
    );
    s#[^a-zA-Z']##g;                           # strip non-alpha chars
    my $re1 = join("|", sort keys %alph);      # replace alpha w/ sort count
    s{($re1)(?=($re1)*$)}{ $alph{$1} }eg;
    return $_;
}

sub ordinal {
    my ($_) = @_;
    return $_ . "st" if m#1$#;
    return $_ . "nd" if m#2$#;
    return $_ . "rd" if m#3$#;
    return $_ . "th";
}

sub word_wrap {
    my ($_, $width) = (@_, 80);
    s#[ \n]+# #g;
    s#(.{1,$width})(?:[ ]+|$)#$1\n#g;
    chomp;
    return $_;
}

sub prettify_entry {
    my ($entry, $order) = @_;
    my @x =  (join("", map {
        prettify_field($entry, $_)
    } @$order) . "\n");
    return @x;
}

sub prettify_field {
    my ($entry, $field) = @_;
    return map {
        my $x = word_wrap($_, 71);
        $x =~ s#^#\t#mg;
        "$field:$x\n";
    } @{ $entry->{$field} };
}


# Usage: @entry = get_entries(
#            data     => \@DATA,
#            offset   => $OFFSET,
#            order    => \@ORDER,
#            callback => \&CALLBACK
#        );
#
# @DATA should contain a section part the database file, each line in a
# separate element (as read by '<>' and extracted by get_section()).
#
# $OFFSET is the line number in the database file of the first line of text in
# @DATA.
#
# @ORDER is a list of field names, containing the names of all allowed fields
# in the order which they must occur within an entry. All allowed field names
# must be included in this list.
#
# &CALLBACK will be called for each each entry as they are processed. It will
# be passed a single entry as argument (see below). The callback should do
# sanity checks of the entry and, if any problems were found, return a list of
# warning messages to be displayed. In an empty list is returned, the entry
# will be considered a-ok.
#
# Return list of entries, containing one hashref for each dictionary entry.
# Hashref key/value pairs corresponds to fields in database. The values,
# however, are listrefs (Usually only containing a single element, but in the
# case of fields allowed to occur multiple times within an entry -- currently
# only the 'site' field -- each field occurance get its own element in the
# listref.)
#
# Each entry also get the special key '_LINE_' containing the line number of
# the start of the entry in the database file.
#
# Here's an example entry (strings slightly truncated):
#
#     $entry = {
#         _LINE_ => 9818,                   # start line in database file
#         tlh    => [ "{nab} [1]" ],
#         pos    => [ "verb" ],
#         sv     => [ "«planera»" ],
#         en     => [ "<plan>" ],
#         def    => [ "TKD" ],
#         ref    => [ "ST5; HQ8:4 pp.12, 13 ('Notes from Star..." ],
#         cite   => [
#             "{nImbuS wej maghoS, He yInab.} 'Plot course ...",
#             "{He pagh-pagh-vagh-jav-pagh-jav yInab} 'Plot...",
#         ],
#         tag    => [ "KLCP1" ],
#         file   => [ "1992-01-01-tkd.txt; 1999-12-holqed-08-..." ],
#     };
#
sub get_entries {
    my %arg = @_;
    my $callback = $arg{callback} // die "get_entries(): No 'callback' specified";
    my $data     = $arg{data}     // die "get_entries(): No 'data' specified";
    my $offset   = $arg{offset}   // die "get_entries(): No 'offset' specified";
    my $order    = $arg{order}    // die "get_entries(): No 'order' specified";
    my $current  = "";  # name of currently processed field
    my $entry    = {};  # currently processed entry
    my $entries  = [];  # complete list of read entries (returned result)
    my %order    = map { $order->[$_] => $_ } 0 .. $#$order;
    warn "Missing blank line after '=== ... ===', at line ${\($offset + 1)}\n"
        if $data->[0] !~ m#^$#;
    $entry = { _LINE_ => $offset + 1 };  # initial value
    LINE: foreach my $i (1 .. $#$data) {
        given ($data->[$i]) {
            when (m#^$#) {                     # blank line
                if (not $current) {
                    warn "Multiple blank lines, at line ${\($offset + $i)}\n";
                } else {
                    if (my @warn = &{ $callback }($entry)) {
                        warn map { "$_ entry at line $entry->{_LINE_}\n" } @warn;
                    } else {
                        push(@$entries, $entry);
                        while (my ($field, $values) = each %$entry) {
                            next if $field eq "_LINE_";
                            foreach my $value (@$values) {
                                my $wrapped = word_wrap($value, 71);
                                if ($value ne $wrapped) {
                                    my ($old, $new) = ($value, $wrapped);
                                    foreach ($old, $new) {
                                        s#^#        #gm;
                                        s# #\e[45m \e[m#g;
                                        s#$#\e[34m¶\e[m#gm;
                                    }
                                    warn "Incorrect wordwrapping line in '$field:' field at line " .
                                        "$entry->{_LINE_}\n" .
                                            "    Current value:\n$old\n" .
                                            "    Should be:\n$new\n";
                                }
                            }
                        }
                        print prettify_entry($entry, $order) if $opt{verbose};
                    }
                    $current = "";
                }
                $entry = { _LINE_ => $offset + $i + 1 };
            }
            when (m#^([^:\h]+):\t(.*)#) {      # field: value line
                my ($field, $value) = ($1, $2);
                if (not exists $order{$field}) {   #   unknown field
                    warn "Unknown field '$field', at line ${\($offset + $i)}\n";
                    # non-fatal error, continue processing
                } elsif ($order{$field} < ($order{$current} // -1)) { # field order
                    warn "Field '$field:' too late in entry sort order " .
                        "at line ${\($offset + $i)}\n";
                    # non-fatal error, continue processing
                }
                warn "Leading space in '$field:' field at line ${\($offset + $i)}\n"
                    if $value =~ s#^\h+##;
                push(@{ $entry->{$field} }, $value);
                $current = $field;
            }
            when (m#^\t(.*)#) {               # indented line
                my $value = $1;
                if ($current) {
                    warn "Leading space in '$current:' field at line ${\($offset + $i)}\n"
                        if $value =~ s#^\h+##;
                    $entry->{$current}[-1] .= "\n$value";
                } else {
                    warn "Unexpected indented line at line &{\($offset + $i)}\n";
                }
            }
            when (m#^===\h.*\h===$#) {        # section separator
                warn "Unexpected '=== ... ===' line at line ${\($offset + $i)}\n";
            }
            default { die "Syntax error in ZDB file at line ${\($offset + $i)}\n" }
        }
    }
    warn "Missing blank line before '=== ... ===', at line ${\($offset + $#$data)}\n"
        if $data->[-1] !~ m#^$#;
    return $entries;
}

sub source_ref_syntax {
    my ($_) = @_;
    my $s  = qr/[  \n]/x;                                   # spaces
    my $p  = qr/[ivx]+|\d+/x;                               # a page number
    my $pp = qr/ p\.$p | pp\.$p(--$p|(,$s$p(--$p)?)+) /x;   # p.#PAGE or pp.#RANGE

    my $chapter  = qr/(K-E|E-K|[0-9]+(\.[0-9]+)+) ($s\($pp\))?/x; # CHAPTER [ (PAGE) ]
    my $chapters = qr/$s$chapter(,$s$chapter)*/x;           # CHAPTER [ (PAGE) ], ...

    # page numbers, chapter numbers, 'E-K' or 'K-E'
    my $tkd_ref  = qr/($chapter|$pp)/x;             #
    my $tkd_refs = qr/ $s $tkd_ref(, $s $tkd_ref)*/x;       #

    # page numbers, 'E-K' or 'K-E'
    my $kgt_ref  = qr/(K-E|E-K) ($s\($pp\))? | $pp/x;
    my $kgt_refs = qr/ $s $kgt_ref(, $s $kgt_ref)*/x;

    # simple page numbers
    my $page_refs = qr/ $s $pp(, $s $pp)*/x;

    my $by    = qr/by$s[^()]+/;         # "by ..."
    my $to    = qr/to$s[^()]+/;         # "to ..."
    my $url   = qr/https?:\/\/[^()]+/;  # "http://..."
    my $subj  = qr/"[^"]+"/;            # "..."
    my $date  = qr/\d{4}-\d{2}-\d{2}/;  # "YYYY-MM-DD"
    my $mdate = qr/\d{4}-\d{2}/;        # "YYYY-MM"
    my $wotf  = qr/Star\s+Trek:\s+The\s+Worlds\s+of\s+the\s+Federation/;

    my $holqed_source  = qr/HQ\d{1,2}:[1-4]+ $page_refs? (?: $s \( $subj \))/x;
    my $paged_source   = qr/( TKDa? $tkd_refs? |KGT $kgt_refs? | (DI|Eurotalk|Sarek|TKW|$wotf) $page_refs?) ($s et $s al\.)? /x;
    my $unpaged_source = qr{
        BoP|CK|PK|KCD|KLINW|TDNW|Radio $s Times|
        S7|S8|S14|S15|S20|S25|S26|S31|S32|S33|ST1|ST5|ST6|STE|
        \{qep'a'\} $s \d{4}                                          |
        Email      $s $date   $s \($by, $s $to    , $s $subj   \)    |
        News       $s $date ( $s \($by, $s $to (?:, $s $subj)? \) )? |
        Web        $s $date   $s \($by, $s $url   , $s $subj   \)    |
        Recording  $s $mdate  $s \([\s\S]*?                    \)
    }x;
    my $source       = qr/$paged_source|$holqed_source|$unpaged_source/x;
    return m#^ $source (;$s$source)* $#x ? TRUE : FALSE;
}

{
    my %bracket = ( '[' => ']', '{' => '}', '(' => ')',
                    '“' => '”', '«' => '»', '<' => '>');
    my %singlet = ( '~' => '~', '"' => '"' );
    my $re = quotemeta join "", sort
        keys %singlet, keys %bracket, values %bracket;
    sub check_brackets {
        my ($_) = @_;
        my (@stack, @warn);
        while (/[$re]/g) {
            if ($singlet{$&}) {                # ~...~ and "..."
                if (@stack and $& eq $stack[-1]) {
                    pop @stack;
                } else {
                    push @stack, $&;
                }
            } elsif ($bracket{$&}) {           # leading bracket
                push(@stack, $&);              #   put on stack
            } else {                           # trailing bracket
                if (@stack and $& eq ($bracket{ $stack[-1] } // "")) { # check ending
                    pop @stack;
                } else {
                    push @warn, "Unexpected $& in";
                }
            }
        }
        push @warn, map { "Unterminated $_ in" } @stack;
        return @warn;
    }
}

{
    my %lect = (
        "older or upper-class word" => "äldre ord eller överklassord",
        "archaic"                   => "arkaiskt",
        "slang"                     => "slang",
        "regional"                  => "regionalt",
        "regional, slang"           => "regionalt, slang",
    );
    # dialect (check that [regional/slang/etc.] are same in 'en:' & 'sv:')
    sub check_dialect {
        my ($lang) = @_;
        my @sv = $lang->{sv} =~ /\[ ([^]]*) \]/gx;
        my @en = $lang->{en} =~ /\[ ([^]]*) \]/gx;
        return () if @en == 0 && @sv == 0;     # no dialect info; skip check
        if (@sv > 1 or @en > 1) {
            return "Only one dialect description '" .
                join(" ", map "[$_]", (@en > 1 ? @en : @sv)) .
                    "' is allowed in 'sv:' and";
        }
        if (@en != @sv) {
            return "Both or none of fields must have dialect " .
                "description in 'en:' and";
        }
        my ($en, $sv) = ($en[0], $sv[0]);
        s/\s/ /g for $en, $sv;
        if (not exists $lect{$en}) {
            return "Unknown dialect description '[$en]' in";
        }
        if ($sv ne $lect{$en}) {
            return "Bad translation of dialect description ('en:[$en]' " .
                "vs 'sv:[$sv]') in 'sv:' and";
        }
        return ();
    }
}


###############################################################################
##                                                                           ##
##  Field Check Callbacks                                                    ##
##                                                                           ##
###############################################################################

# These checks are passed the one entry + name of a field to check. Values of
# fields are always a LISTREF (where multiple occurances of the field is
# allowed, e.g. for 'cite' this listref will contain multiple elements, but
# most commonly there will be just one element).
#
# Callback functions are expected to return a list of strings, each describing
# a problem (if found). Should return empty list if no problems were found.
#
# $field = "tlh" # i.e. field name
# $entry = {
#     KEY => [ qw/ VALUE... / ],  # one VALUE for each occurance of field
#     ...
# }
#
# Return list of error messages or empty list if ok.

sub check_tlh {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    my $pos  = $entry->{pos}[0]  // "";        # part-of-speech
    my $data = $entry->{data}[0] // "";        # data field

    # get/check word counters
    my ($pre, $word, $post) = m#^(.*?)(\*?\{[^{}]*\})(.*?)$#
        ? ($1, $2, $3) : ("", "", "");
    return "Mising Klingon word '{...}' in" unless $word;
    push @warn, "Not single space between '$pre' and '$word' in"
        if $pre and $pre =~ s#(\h*)$## and length($1) != 1;
    push @warn, "Not single space between '$word' and '$post' in"
        if $post and $post =~ s#^(\h*)## and length($1) != 1;

    if ($word =~ m#\h#) {
        push @warn, "Missing tag 'phrase' in 'data:' field when there are " .
            "several words {...} in" unless $data =~ m#\bphrase\b#m;
    }

    my $hyp = do {                            # pre-word counter
        if ($pre =~ m#^\[(\d+)\]$#) {
            $1 // 0;
        } else {
            push @warn, "Invalid pre-word data '$pre' for '$word' in" if $pre;
            0;
        }
    };
    my ($sub, $subsub) = do {                 # post-word counter and sub-counter
        if ($post =~ m#^\[(\d+)?(?:\.(\d+))?\]$#) {
            ($1 // 0, $2 // 0);
        } else {
            push @warn, "Invalid post-word data '$post' for '$word' in" if $post;
            (0, 0);
        }
    };

    state $prev_word   = "";
    state $prev_pos    = "";
    state $prev_hyp    = 0;
    state $prev_sub    = 0;
    state $prev_subsub = 0;
    if ($word eq $prev_word) {                 # change (= clear counters)
        push @warn, "Duplicate entry '$word' in"
            if $hyp == $prev_hyp and $sub == $prev_sub and $subsub == $prev_subsub;
        # check that counters did not disappear when they weren't supposed to
        push @warn, "Pre-word counter '[" . ($prev_hyp + 1) . "]' missing for '$word' in"
            if $hyp == 0 and $prev_hyp > 1;
        push @warn, "Post-word counter '[" . ($prev_sub + 1) . "]' missing for '$word' in"
            if $sub == 0 and $prev_sub > 0 and $hyp == $prev_hyp;
        push @warn, "Post-word sub-counter '[." . ($prev_subsub + 1) . "]' missing for '$word' in"
            if $subsub == 0 and $prev_subsub > 0 and $sub == $prev_sub and $hyp == $prev_hyp;
    } else {
        push @warn,  "Pre-word ". "counter for previous entry stopped at '[1]' in"
            if $prev_hyp    == 1;
        push @warn, "Post-word ". "counter for previous entry stopped at '[1]' in"
            if $prev_sub    == 1;
        push @warn, "Post-word sub-counter for previous entry stopped at '[.1]' in"
            if $prev_subsub == 1;
        ($prev_hyp, $prev_sub, $prev_subsub) = (0, 0, 0);
    }

    if ($hyp) {                                # pre-word counter
        if ($hyp != $prev_hyp + 1) {           #   bad: not +1 change in counter
            push @warn, "Pre-word counter '[$hyp]' for '$word' may only " .
                "increase by one in"
                    unless $hyp == $prev_hyp and ($sub or $subsub);
        } else {                               #   ok: +1 change, clear subcount
            if ($hyp == 1) {                   #     initialized (= set to one)
                push @warn, "pre-word counter '[$hyp]' for '$word' may only " .
                    "be set to one when word changes, in" if $word eq $prev_word;
            } else {                           #     incremented
                push @warn, "pre-word counter '[$hyp]' for '$word' may only " .
                    "increase when word remains same, in" if $word ne $prev_word;
            }
            push @warn, "post-word ". "counter for previous entry stopped " .
                "at '[1]' in" if $prev_sub    == 1;
            push @warn, "post-word sub-counter for previous entry stopped " .
                "at '[.1]' in" if $prev_subsub == 1;
            ($prev_sub, $prev_subsub) = (0, 0);
        }
    }
    if ($sub) {                                # post-word counter
        if ($sub != $prev_sub + 1) {           #   bad: not +1 change in counter
            push @warn, "Post-word counter '[$sub]' for '$word' may only " .
                "increase by one in"           #     no change: will subcount change?
                    unless $sub == $prev_sub and $subsub;
        } else {                               #   ok: +1 change, clear subcount
            if ($sub == 1) {                   #     initialized (= set to one)
                push @warn, "Post-word counter '[$sub]' for '$word' may only " .
                    "be set to one when word or higher counter change in"
                        if $word eq $prev_word && $hyp == $prev_hyp;
            } else {                           #     incremented
                push @warn, "Post-word counter '[$sub]' for '$word' may only " .
                    "increase when part-of-speech change in"
                        if $pos eq $prev_pos;
            }
            push @warn, "Post-word sub-counter for previous entry stopped " .
                "at '[.1]' in" if $prev_subsub == 1;
            $prev_subsub = 0;
        }
    }
    if ($subsub) {                             # post-word sub-counter
        if ($subsub != $prev_subsub + 1) {     #   bad: not +1 change in counter
            push @warn, "Post-word sub-counter '[.$subsub]' " .
                "for '$word' may only increase by one in";
        } else {                               #   ok: +1 change, clear subcount
            if ($subsub == 1) {                #     initialized (= set to one)
                push @warn, "Post-word sub-counter '[.$subsub]' for '$word' " .
                    "may only be set to one when word or higher counter change in"
                        if $word eq $prev_word && $hyp == $prev_hyp && $sub == $prev_sub;
            } else {                           #     incremented
                push @warn, "Post-word sub-counter '[.$subsub]' for '$word' " .
                    "may only increase when part-of-speech remains same in"
                        if $pos ne $prev_pos;
            }
        }
    }
    ($prev_word, $prev_pos, $prev_hyp, $prev_sub, $prev_subsub) = ($word, $pos, $hyp, $sub, $subsub);

    # check klingon spelling
    state $re = qr/ (?:[bDHjlmnpqQrStvwy']|ch|gh|ng|tlh)(?:
            [aeI] (?:[bDHjlmnpqQrStv']|ch|gh|ng|tlh|[wy]'?|rgh)? |
            [ou]  (?:[bDHjlmnpqQrStv']|ch|gh|ng|tlh|  y '?|rgh)?    # "ow" and "uw" is not allowed
    )/x;
    if (not $word =~ m#^\*?\{(?:$re+(?:\s$re+|\s«$re+»)*|$re?-|-$re)\}$#o) {
        # non-phonotactic word
        push @warn, "Invalid syllable structure for '$word' in"
            if $data !~ m#\bnon-phonotactic\b#;
    } else {
        push @warn, "Incorrectly tagged 'non-phonotactic' in 'data:' " .
            "field, word '$word' is good in"
                if $data =~ m#\bnon-phonotactic\b#;
    }
    if (m#^\*#) {
        push @warn, "Missing 'warn:' field when there is a leading asterisk in"
            unless $entry->{warn};
        push @warn, "Missing 'see:' field when there is a leading asterisk in"
            unless $entry->{see};
        push @warn, "Missing 'deprecated' or 'non-canon' in 'data:' field " .
            "when there is a leading asterisk in"
            if $data !~ m#\b(?:deprecated|non-canon)\b#m;
    }
    return @warn;
}

sub check_warn {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    push @warn, check_brackets($_);
    my $tlh  = $entry->{tlh}[0]  // "";
    my $data = $entry->{data}[0] // "";
    push @warn, "First letter not lower case in" if m#^[A-Z]# and !/^I\b/;
    push @warn, "Last character is punctuation in" if m#[-.,:;([{<«  ]$#;
    push @warn, "Missing leading asterisk in 'tlh:' field when there is a"
        unless $tlh =~ m#^[*]#;
    if (/\bnon-canon\b/) {
        push @warn, "Missing 'non-canon' in 'data:' field when " .
            "'non-canon' is given in" if $data !~ m#\bnon-canon\b#m;
    } elsif (/\bcanon\b/) {
        push @warn, "Missing 'deprecated' in 'data:' field when " .
            "'canon' is given in" if $data !~ m#\bdeprecated\b#m;
    } else {
        push @warn, "Missing word 'canon' or 'non-canon' in";
    }
    return @warn;
}

sub check_pos {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    state $re = qr{^(?:
        verb(?:\s(?:prefix|suffix\stype\s(?:[1-9]|rover)))?|
        noun(?:\ssuffix\stype\s[1-5])?|
        name|adverbial|conjunction|exclamation|numeral|pronoun|question\sword
    )$}x;
    push @warn, "Invalid part-of-speech '$_' in" unless m#$re#o;
    return @warn;
}

sub check_en {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    push @warn, check_brackets($_);

    # <...> or «...» are required (except for affixes)
    my $pos = $entry->{pos}[0] // "";          # part-of-speech
    push @warn, "Missing «...» or <...> brackets in"
        if $pos !~ m#\b(suf|pre)fix\b#m and !/[<«]/;

    # may not end in punctuation (question mark is okay)
    push @warn, "Last character is punctuation in" if m#[-!.,:;([{<«  ]$#;
    if (m#\((v|n|name|adv|conj|excl|num|pro|ques|ns[1-5]|vp|vs[1-9r])\)#) {
        push @warn, "Part-of-speech '($1)' must not be given in";
    }

    push @warn, check_dialect({
        en => $_,
        sv => $entry->{sv}[0],
    });
    return @warn;
}

sub check_sv {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    push @warn, check_brackets($_);

    # «...» are required (except for affixes), <...> may not occur
    my $pos = $entry->{pos}[0] // "";          # part-of-speech
    push @warn, "Missing «...» brackets in"
        if $pos !~ m#\b(suf|pre)fix\b#m and !/«/;
    push @warn, "<...> brackets are not allowed in" if m#[<>]#;

    # may not end in punctuation (question mark is okay)
    push @warn, "Last character is punctuation in" if m#[-!.,:;([{<«  ]$#;
    if (m#\((v|s|namn|adv|konj|interj|räkn|pro|fråg|ss[1-5]|vp|vs[1-9]s)\)# or
            m#\((v|n|name|adv|conj|excl|num|pro|ques|ns[1-5]|vp|vs[1-9r])\)#) {
        push @warn, "Part-of-speech '($1)' must not be given in";
    }

    return @warn;
}

sub check_desc {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    push @warn, check_brackets($_);
    push @warn, "First letter not lower case in" if m#^[A-Z]# and !/^I\b/;
    while (m#~([^~]+)~#g) {                    # check ~...~ phrases
        my $_ = $1;
        push @warn, "First letter in '~$_~' is not lower case in"
            if m#^[A-Z]# and !/^I\b/;
        push @warn, "Last character in '~$_~' is punctuation in"
            if m#[-.,:;([{<«  ]$# and not m#\b(?:subj|obj)\.$#;
    }
    # punctuation not allowed at end, except as part of abbrev
    push @warn, "Last character is punctuation in"
        if m#[-.,:;([{<«  ]$# and !/(?:subj|obj)\.$/;
    push @warn, "Word '$1' should be abbreviated in"
        if m#\b(some(bod(y|ies)|ones?|things?))\b#;
    return @warn;
}

# used for both 'def' and 'ref'
sub check_source {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    (my $x = $_) =~ s/"[^"]*"//g;              # remove title from comp'd string
    push @warn, check_brackets($x);
    push @warn, "Invalid source reference in" unless source_ref_syntax($_);
    return @warn;
}

sub check_cite {
    my ($entry, $field, $_, @warn) = @_;
    my $i = 1;
    foreach (@{ $entry->{$field} }) {
        my $_ = $_;
        if (s#\[([^][]*)\]$##) {
            if (not source_ref_syntax($1)) {
                push @warn, "Invalid source reference '$1' in ${\( ordinal($i) )}";
            }
        } else {
            push @warn, "Missing source reference in ${\( ordinal($i) )}";
        }
        push @warn, check_brackets($_);
        $i += 1;
    }
    return @warn;
}

sub check_pun {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    push @warn, check_brackets($_);
    push @warn, "Last character is mid-sentence punctuation in"
        if m#[-,:;([{<«  ]$#;
    return @warn;
}

sub check_com {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    if (s#\s*\[([^\[\]]*)\]$## and not source_ref_syntax($1)) {
        push @warn, "Invalid source reference '$1' in";
    }
    push @warn, check_brackets($_);
    push @warn, "Last character is mid-sentence punctuation in"
        if m#[-,:;([{<«  ]$#;
    return @warn;
}

sub check_see {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    push @warn, check_brackets($_);
    # FIXME what if 'tlh:' field isn't defined here (?)
    my ($tlh) = $entry->{tlh}[0] =~ m#(\{.*?\})#;
    push @warn, "See also '$tlh' points to itself in"
        if defined($tlh) and m#$tlh#;
    return @warn;
}

{
    my %tag = map {
        (my $_ = $_) =~ s/_/ /g;
        $_ => 1;
    } qw(animal architecture body_part clothing country family fighting KLCP1
         landscape math measure money music placement quantity religion shape
         time);
    sub check_tag {
        my ($entry, $field, $_) = @_;
        return "Duplicate" if @{ $entry->{$field} } > 1;
        my @warn;
        foreach (split /;\s/) {
            push @warn, "Unknown tag '$_' in"
                unless exists $tag{$_};
        }
        return @warn;
    }
}

sub check_data {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    push @warn, check_brackets($_);
    my $tlh = $entry->{tlh}[0] // "";
    if (/\b(deprecated|non-canon)\b/) {
        push @warn, "Missing leading asterisk in 'tlh:' field as '$1' is given in"
            unless $tlh =~ m#^[*]#;
    }
    if (/\b(phrase)\b/) {
        push @warn, "Missing space in 'tlh:' field as '$1' is given in"
            unless $tlh =~ m#^[^{]* {[^{]*[ ] [^{]*} #x;
    }
    return @warn;
}

{
    # character class matching base58
    my $char_class = join "", grep(!/[0OIl]/, "a".."z", "A".."Z", "0".."9");
    my $content_ok_re = qr/^[$char_class]{3}$/;
    # check that ID doesn't look too much like a Klingon word
    my $tlh_re = qr/^([bDHj1mnpqQrStvwy]|ch|gh|ng|t1h)[ouae1]?[bDHj1mnpqQrStvwy]?$/x;
    my %id_found = ();
    sub check_id {
        my ($entry, $field, $_, @warn) = @_;
        return "Duplicate" if @{ $entry->{$field} } > 1;
        return "Not three base58 characters in in" if not /$content_ok_re/;
        return "Value '$_' is too similar to Klingon word in" if /$tlh_re/;
        return "Value '$_' already exist in" if $id_found{$_};
        $id_found{$_} = TRUE;
        return @warn;
    }
}

sub check_file {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    foreach (split(m#;[ \n]#, $_)) {
        my $file = "$cfg{canon_path}/$_";
        push @warn, "Invalid file '${\( File::Spec->abs2rel($file) )}' in"
            unless -e $file;
    }
    return @warn;
}

sub check_meta {
    my ($entry, $field, $_, @warn) = @_;
    return "Duplicate" if @{ $entry->{$field} } > 1;
    push @warn, check_brackets($_);
    push @warn, "First letter not upper case in" unless m#^(["A-Z]|\*?\{)#x;
    push @warn, "Last character is mid-sentence punctuation in" if m#[-,:;([{<«  ]$#;
    return @warn;
}

# Usage: check_entry(\@REQUIRED, \%CALLBACKS, \%ENTRY);
#
# Checks that all required fields are present, and invoke callbacks to check
# field values.
#
# Return list of warnings or empty list if entry was a-ok.
#
# @REQUIRED is list of fields which *must* be present in an entry (in no
# particular order).
#
# %CALLBACKS is a hash with check callbacks to invoke for each field. (No
# checks will be performed on fields for which there is no check function.)
#
# Keys are field names, and values are coderefs to invoke. Each callback is
# called as FUNCTION(\%ENTRY, $FIELD). Callback should return a list of
# warnings or empty list if checked field was a-ok.
#
# %ENTRY is a single dictionary entry. A hashref with listrefs as values.
# Multiple elements for the listrefs only occur for fields that occur multiple
# times within the same entry (e.g. 'cite').
sub check_entry {
    my ($required, $callbacks, $entry) = @_;
    my @warn = ();
    # check that required fields exists
    foreach (@$required) {
        push(@warn, "Missing required '$_:' field in")
            unless exists($entry->{$_});
    }
    # invoke callbacks for each field
    foreach (keys %$entry) {
        next unless exists $callbacks->{$_};
        my $field = $_;
        push @warn, map {
            "$_ '$field:' field in";
        } &{ $callbacks->{$_} }($entry, $_, $entry->{$_}[0]);
    }
    return @warn;
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

use Getopt::Long qw(
    :config posix_default bundling gnu_compat no_ignore_case permute
);
GetOptions(                          # info displayed by help()
    'checksum|c' => \$opt{checksum}, ### only check SHA1 sum in metadata
    'help|h'     => \&help,          ### display this help and exit
    'manpage|M'  => \&manpage,       ### display program manpage and exit
    'quiet|q'    => \$opt{quiet},    ### suppress word count summary at end
    'verbose|v'  => \$opt{verbose},  ### output normalized dictionary on STDOUT
    'version|V'  => \&version,       ### output version information and exit
) or exit 255;

die "$NAME: Missing input: Nothing on standard input, and no file specified\n" .
    "Use '$NAME --help' for more information.\n"
    if -t STDIN and @ARGV == 0;

###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

my $warnings = 0;                              # count warnings
local $SIG{__WARN__} = sub { $warnings ++; warn @_ };

my @whole_file = <>;  # read dictionary
my ($preamble, $datachunk, $enddelim, $postamble) =
    get_section("==", "data", \@whole_file) or exit 255;

# check metadata header
my %meta = get_metadata(@whole_file);
{                                              # check metadata 'SHA1'
    my $sha1 = sha1sum($datachunk);
    if ($sha1 ne $meta{SHA1}) {
        warn "Invalid 'SHA1' metadata (should be '$sha1')\n";
    }
    exit !!$warnings if $opt{checksum};        # abort on --checksum
    if ($opt{verbose} and $sha1 ne $meta{SHA1}) {
        foreach (@$preamble) {
            last if m#^$#;
            last if s#^(SHA1:\s*).*$#$1$sha1#;
        }
    }
}

# check line length and linefeed at end of file
# FIXME: should also check for PC line endings, and non-UTF8 (?)
foreach my $line (0..$#whole_file) {
    my $_ = $whole_file[$line];
    s{\t}{ " " x (8 - (pos() % 8)) }ge;  # replace tabs with spaces
    if (length($_) > 80) { # 80 = is with trailing newline
        warn "Line may not exceed 79 characters in line " . ($line + 1) . "\n";
    }
    if (/\h+$/) {
        warn "Trailing space at line " . ($line + 1) . "\n";
    }
}
if ($whole_file[-1] !~ m#\n$#) {
    warn "Missing linefeed at end of file at line " . ($#whole_file + 1) . "\n";
}

print @$preamble if $opt{verbose};


my ($prefix_count, $suffix_count, $word_count, $marked_count) = (0, 0, 0, 0);
my $offset = @$preamble + 1;
foreach my $section (qw/word verb-prefix verb-suffix noun-suffix/) {

    my ($preamble2, $datachunk2, $enddelim, $remaining) =
        get_section("===", "$section-list", $datachunk) or do {
        $warnings ++;
        next;
    };
    $datachunk = $remaining;                   # remaining in text datachunk

    print @$preamble2, "\n" if $opt{verbose};
    $offset   += @$preamble2;                  # adjust offset
    my $entries = get_entries(
        data     => $datachunk2,
        offset   => $offset,
        order    => $cfg{field_order},
        callback => sub {
            check_entry($cfg{field_required}, $cfg{field_callbacks}, @_);
        },
    );
    $offset += @$datachunk2 + @$enddelim;
    print @$enddelim if $opt{verbose};

    # check sort order in dictionary
    my ($last_sortkey, $last_word) = ("", "");
    foreach my $entry (@$entries) {
        $_ = $entry->{tlh}[0] // "";
        my ($marked, $word) = m#^.*? (\*?) \{([^}]*)\} .*? $#xm;
        $marked_count ++ if $marked;
        given ($word) {
            when (/-$/) { $prefix_count ++ }
            when (/^-/) { $suffix_count ++ }
            default     {   $word_count ++ unless $marked }
        }
        my $sortkey = sortkey_tlh($word);
        my $order   = ($last_sortkey cmp $sortkey);
        if ($order == 1) {
            warn "Wrong sort order: {$last_word} comes before {$word}, " .
                "in entry at line " . ($entry->{_LINE_}) . "\n";
        }
        $last_sortkey = $sortkey;
        $last_word    = $word;
    }
}

print @$enddelim, @$postamble if $opt{verbose};
warn "Last line must be '[[eof]]' at line " . scalar(@whole_file) . "\n"
    unless $whole_file[-1] =~ m#^\[\[eof\]\]$#;

print STDERR
    "Word count: $word_count (" .
    "prefixes: $prefix_count, " .
    "suffixes: $suffix_count, " .
    "*deprecated: $marked_count)\n"
    unless $opt{quiet};

exit !!$warnings;

__END__

=head1 NAME

check-dict - check consistency of Klingonska Akademien's Klingon database file


=head1 SYNOPSIS

B<check-dict> [I<OPTION>]... [I<FILE>]


=head1 DESCRIPTION

This tool is used to check the integrity of Klingonska Akademien's I<Online
Klingon Pocket Dictionary> database <http://klingonska.org/dict/>, and report
any problems and inconsistencies within it.

The database is in ZDB (Zrajm DataBase) format, a very simple text format,
intended to be human readable, as well as machine parsable. The database is
available online for browsing or fetching for anyone who wishes to do so. It
also contains a metadata header intended to simplify syncing against the
dictionary for external apps and programs.


=head1 OPTIONS

Mandatory arguments to long options are mandatory for short options too.


=over 8

=item B<-c>, B<--checksum>

Fast way to only check the 'SHA1' checksum of the metadata (all other checks as
are skipped). This option is primarily intended for use in publish and commit
hooks (where speed is of the essence).

It is vitally important that the 'SHA1' metadata field correctly reflects the
database content at all times, since this is used by external apps and programs
that wishes to sync against the dictionary. Implies B<--quiet>.


=item B<-h>, B<--help>

Output brief command line help on standard output, then exit.


=item B<-M>, B<--manpage>

Display program manpage and exit. This option extracts the Perl POD (Plain Old
Documentation) documentation from the program and displays it using man(1).


=item B<-q>, B<--quiet>

Suppress the word count summary at the end of processing.


=item B<-v>, B<--verbose>

Output a re-word wrapped dictionary on standard output during processing.

This output should ideally be the same as the input, but if the B<check-dict>
terminates with a zero exit status, then the dictionary is, for all intents and
purposes, error free.


=item B<-V>, B<--version>

Output version information on standard output, then exit.

=back


=head1 EXIT STATUS

Exit status will be 0 if all checks were passed, 1 if one or more checks failed
and 255 if B<check-dict> died for some other reason (unknown options, missing
input, whatever).


=head1 EXAMPLES

Here are a couple of examples. After each example comes an explanation of what
it does.

    bin/check-dict <site/dict/dict.zdb

This is how one would typically invoke B<check-dict>. It runs all checks and
does all the stuff one expects.

    bin/check-dict --checksum <site/dict/dict.zdb

This forgoes most of the checks, loads the dictionary and only checks the
'SHA1' checksum of the metadata. It is primary intended for use in publish and
commit hooks (as it is vitally important that this value never is incorrect for
syncing to work well for external programs/apps).

    bin/check-dict --verbose site/dict/dict.zdb | diff site/dict/dict.zdb -

Compare difference in word wrapping between the existing dictionary file, and
an "ideal" version of it. B<--verbose> outputs the file in re-wrapped for on
standard output, here we simply feed that to diff(1) to see if there are any
differences.


=head1 AUTHOR

Written by Zrajm C Akfohg <zrajm@klingonska.org>, 2009-2012.


=head1 COPYRIGHT AND LICENSE

Copyright 2012 Zrajm C Akfohg <zrajm@klingonska.org>.

Distributed under Creative Commons Attribution-ShareAlike 3.0 Unported (CC
BY-SA 3.0) http://creativecommons.org/licenses/by-sa/3.0/

This means that you may copy, sell and change the program in any way you like,
as long as you still attribute it to this author, and release your modified
version under the same license.


=head1 SEE ALSO

Take a look at the database file itself for a description of its format
http://klingonska.org/dict/dict.zdb.

For a web interface to the dictionary, see Klingonska Akademien's I<Online
Klingon Pocket Dictionary> (at http://klingonska.org/dict/), and for other
stuff about the Klingon language, see Klingonska Akademien's web site in
general http://klingonska.org/.

=cut

#[eof]
